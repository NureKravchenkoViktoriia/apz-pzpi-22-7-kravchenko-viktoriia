МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 


Кафедра «Програмна інженерія»
 



ЗВІТ
з практичної роботи №1
з дисципліни «Архітектура програмного забезпечення»
на тему «Патерни проєктування»
 



 
Виконала:                                                           	              	Прийняв:
ст. гр. ПЗПІ-22-7                                    	       	     		Сокорчук І. П.
Кравченко В. А.







Харків 2025
1 ІСТОРІЯ ЗМІН


№ДатаВерсія звітуОпис змін та виправлень111.05.20250.1Створено розділ «Історія змін» та «Завдання»214.05.20250.1Створено розділ «Опис виконаної роботи»314.05.20250.1Створено розділ «Висновки»417.05.20250.1Створено «Додаток А», «Додаток Б» та «Додаток В»


















2 ЗАВДАННЯ


     Метою роботи є дослідження та систематизація знань про патерн проектування "Спостерігач" (Observer). Основні завдання включають:
     Ознайомлення з теоретичними основами патерна Observer — з’ясування мети використання даного шаблону, принципів його роботи, а також сфери застосування в об’єктно-орієнтованому програмуванні.
     Аналіз концептуальних основ патерну:
     • Визначення сутності патерну "Спостерігач" через призму відношення "один до багатьох" між об'єктами.
     • Дослідження структурних компонентів: об'єкта-видавця (Subject), підписників (Observers), механізму підписки та сповіщення.
     • Порівняння з альтернативними назвами патерну ("Видавець-Передплатник") та їх семантикою.
     Розкриття практичного застосування:
     • Аналіз типових сценаріїв використання: оновлення інтерфейсів при зміні даних, розподілені системи подій, динамічні залежності між компонентами.
     • Демонстрація переваг слабкого зв'язування між об'єктами та автоматизації процесу оновлення.
     • Визначення переваг та недоліків використання патерна Observer — критичне оцінювання доцільності його використання в різних умовах, з урахуванням таких критеріїв, як гнучкість, масштабованість, підтримуваність коду тощо.
     • Вивчення типових сценаріїв використання шаблону Observer у програмному забезпеченні — наведення прикладів застосування патерна в реальних ІТ-системах (наприклад, у графічних інтерфейсах користувача, системах обміну повідомленнями, подієво-орієнтованому програмуванні тощо).
     • Формалізований опис патерна згідно з рекомендаціями GoF — представлення шаблону у стандартному форматі: назва, альтернативні назви, мотивація, структура, учасники, співпраця, наслідки, приклади реалізації.
     Формалізація вимог до оформлення:
     • Дотримання структури звіту згідно ДСТУ 3008:2015: титульний аркуш, зміст, розділи "Історія змін", "Завдання", "Опис виконаної роботи", "Висновки".
     • Використання науково-технічного стилю з урахуванням офіційної термінології (наприклад: "інкапсуляція", "механізм підписки", "імплементація інтерфейсів").
     • Уникнення англіцизмів (замість "Subject" – "Видавець", замість "Notify" – "Сповіщення").
     Створити та оформити слайди презентації доповіді.
     Створити та опублікувати на YouTube відеозапис доповіді.
     Оформити та завантажити на dl.nure.ua звіт до виконаної роботи.
     При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua.
     Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main.
     Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань.
     Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub.
     Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1.





3 ОПИС ВИКОНАНОЇ РОБОТИ


     Патерн проектування "Спостерігач" (Observer) належить до поведінкових патернів, які визначають способи взаємодії між об’єктами у програмних системах. Основна мета цього патерну полягає у створенні механізму підписки, що дозволяє одним об’єктам (підписникам) стежити за змінами стану інших об’єктів (видавців) та реагувати на ці зміни без жорсткого зв’язку між ними.
     У контексті об’єктно-орієнтованого програмування патерн "Спостерігач" забезпечує динамічний односторонній зв’язок між об’єктами, де один об’єкт (видавець) повідомляє інші об’єкти (спостерігачів) про зміну свого стану. Це дозволяє реалізувати слабке зв’язування, підвищуючи гнучкість і масштабованість системи.
     Аналіз концептуальних основ патерну:
     Визначення сутності патерну через відношення "один до багатьох":
     Патерн "Спостерігач" базується на відношенні "один до багатьох", де один об’єкт-видавець підтримує список підписників (спостерігачів), які бажають отримувати повідомлення про зміни стану видавця. Коли відбувається зміна стану, видавець автоматично сповіщає всіх підписників, викликаючи у них визначений інтерфейсний метод оповіщення. Таким чином, кожен спостерігач може реагувати на подію відповідно до своєї логіки.
     Структурні компоненти патерну:
     Патерн складається з таких основних учасників:
     • Видавець (Subject) - об’єкт, який містить важливий стан і підтримує список спостерігачів. Видавець надає методи для додавання та видалення спостерігачів (підписка/відписка) і метод сповіщення, що викликає оновлення у всіх зареєстрованих спостерігачів.
     • Спостерігачі (Observers) - об’єкти, які підписуються на видавця і реалізують інтерфейс, що містить метод оновлення, який викликається при зміні стану видавця.
     • Інтерфейси - загальні контракти, які визначають методи підписки, відписки та оновлення, що забезпечують слабке зв’язування між видавцем і спостерігачами.
     Ця структура дозволяє динамічно управляти підписниками, додавати нові типи спостерігачів без зміни коду видавця, що підвищує гнучкість архітектури.
     Порівняння з альтернативними назвами патерну:
     Патерн "Спостерігач" часто називають також "Видавець-Передплатник" (Publisher-Subscriber), що підкреслює сутність взаємодії: видавець розсилає повідомлення, а передплатники їх отримують. Ця назва акцентує увагу на механізмі підписки та розсилки подій, що є ключовим для патерну. Семантично обидві назви відображають одну й ту ж концепцію, проте "Спостерігач" більше фокусується на ролі об’єктів, які спостерігають за змінами, а "Видавець-Передплатник" - на процесі комунікації між ними.
     У деяких випадках патерн "Спостерігач" використовується для реалізації інших патернів, наприклад, "Посередника" (Mediator), де посередник виступає видавцем, а компоненти системи - передплатниками. Проте між цими патернами існують відмінності у способах організації взаємодії та ступені зв’язності між об’єктами.
     Таким чином, теоретичні основи патерну "Спостерігач" базуються на створенні гнучкої системи підписки та сповіщення, що забезпечує слабке зв’язування між об’єктами і дозволяє ефективно управляти динамічними залежностями в об’єктно-орієнтованих системах.
     
     Розкриття практичного застосування патерну "Спостерігач":
     Аналіз типових сценаріїв використання:
     Патерн "Спостерігач" широко застосовується у різноманітних програмних системах, де необхідно забезпечити автоматичне оновлення одних компонентів при зміні стану інших. Основні типові сценарії:
     • Оновлення інтерфейсів користувача при зміні даних
     У графічних інтерфейсах (GUI) часто потрібно, щоб різні елементи відображали актуальний стан даних. Наприклад, у текстовому редакторі зміна документа має негайно відобразитися у вікні перегляду, панелі стану або інших компонентах. Патерн "Спостерігач" дозволяє підписати всі ці компоненти на об’єкт даних (Видавець) і автоматично оновлювати їх при зміні.
     • Розподілені системи подій
     У системах з подієвою архітектурою (event-driven architecture) патерн використовується для розсилки подій між модулями або сервісами. Наприклад, у системах обміну повідомленнями або у веб-додатках, коли зміна стану одного компонента має інформувати інші частини системи.
     • Динамічні залежності між компонентами
     У складних програмних продуктах, де компоненти можуть з’являтися або зникати під час виконання, патерн "Спостерігач" дозволяє динамічно додавати або видаляти підписників без зміни коду Видавця. Це забезпечує гнучкість і розширюваність системи.
     Демонстрація переваг слабкого зв’язування між об’єктами та автоматизації процесу оновлення:
     Патерн "Спостерігач" реалізує слабке зв’язування між об’єктами, оскільки Видавець знає лише про інтерфейс Спостерігачів, але не про їх конкретну реалізацію. Це зменшує залежність між компонентами і полегшує їх модифікацію або заміну.
     Автоматизація процесу оновлення полягає в тому, що Видавець самостійно сповіщає всіх підписників про зміну стану, що виключає необхідність ручного опитування або перевірки стану. Це підвищує ефективність і зменшує ймовірність помилок, пов’язаних із синхронізацією даних.
     Визначення переваг та недоліків використання патерна Observer:
     Переваги:
     • Гнучкість і розширюваність: легко додавати нових Спостерігачів без зміни коду Видавця.
     • Слабке зв’язування: Видавець і Спостерігачі взаємодіють через абстрактні інтерфейси, що підвищує модульність.
     • Автоматичне оновлення: Спостерігачі миттєво отримують повідомлення про зміни, що підвищує узгодженість стану.
     • Підтримка динамічних залежностей: Підписка і відписка можуть відбуватися під час виконання програми.
     Недоліки:
     • Можливість надмірних сповіщень: якщо кількість Спостерігачів велика, або зміни відбуваються часто, це може призводити до зниження продуктивності.
     • Циклічні залежності: якщо Спостерігачі також змінюють стан Видавця, може виникнути ризик нескінченних циклів оновлення.
     • Відсутність гарантії порядку оновлення: Порядок сповіщення Спостерігачів зазвичай не визначений, що може бути критично у деяких системах.
     • Складність відлагодження: через розподілену природу оновлень іноді важко відстежити джерело зміни стану.
     
     Вивчення типових сценаріїв використання шаблону Observer у програмному забезпеченні:
     Патерн "Спостерігач" (Observer) є одним із найпоширеніших поведінкових патернів, що застосовується в різних сферах програмного забезпечення, де необхідно забезпечити автоматичне та своєчасне інформування зацікавлених компонентів про зміни стану об’єкта. Нижче наведено типові сценарії використання патерну в реальних ІТ-системах.
     1. Графічні інтерфейси користувача (GUI):
     У розробці інтерфейсів користувача патерн Observer використовується для синхронізації відображення з моделлю даних. Наприклад, у архітектурі Model-View-Controller (MVC) модель (Model) виступає як Видавець, а представлення (View) - як Спостерігачі. Коли дані моделі змінюються, всі пов’язані вікна, панелі або інші компоненти автоматично оновлюються без необхідності ручного втручання.
     Приклад: У Java Swing або .NET Windows Forms події зміни даних моделі викликають оновлення відповідних елементів інтерфейсу.
     2. Системи обміну повідомленнями та подієво-орієнтоване програмування:
     У системах, де відбувається обробка подій (event-driven systems), патерн Observer дозволяє реалізувати механізм підписки на події. Наприклад, у чат-додатках користувачі підписуються на повідомлення в групових чатах, і при надходженні нового повідомлення система сповіщає всіх підписаних користувачів.
     Приклад: У платформах Slack або WhatsApp користувачі отримують миттєві оновлення про нові повідомлення завдяки механізму сповіщення.
     3. Розподілені системи та серверні додатки:
     У розподілених системах патерн застосовується для широкомовного оповіщення компонентів про зміни стану, наприклад, у системах моніторингу або торгівлі на фондових біржах. Клієнти можуть підписуватися на потоки даних (акції, курси валют), отримуючи миттєві оновлення.
     Приклад: Біржові платформи, такі як Robinhood або Coinbase, надсилають оновлення ціни акцій або криптовалют усім зацікавленим користувачам.
     4. Системи сповіщень і оповіщень:
     Патерн широко використовується у мобільних додатках для сповіщень про нові події, наприклад, оновлення погоди, новини або системні повідомлення.
     Приклад: Додатки погоди повідомляють користувачів про зміни погодних умов у реальному часі.
     Формалізований опис патерна Observer згідно з рекомендаціями GoF:
     Для систематичного представлення патерну "Спостерігач" застосуємо стандартну структуру, рекомендовану в книзі "Патерни проектування" (GoF).
ЕлементОписНазваСпостерігач (Observer)Альтернативні назвиВидавець-Передплатник (Publisher-Subscriber), Підлеглі (Dependents)МотиваціяЗабезпечити механізм автоматичного сповіщення групи об’єктів про зміну стану іншого об’єкта без жорстких зв’язків.СтруктураВключає Видавця (Subject), який підтримує список Спостерігачів (Observers) та сповіщає їх про зміни.Учасники- Видавець (Subject): інтерфейс для реєстрації, видалення та сповіщення Спостерігачів. 
- Конкретний Видавець (ConcreteSubject): реалізує інтерфейс, зберігає стан і сповіщає. 
- Спостерігач (Observer): інтерфейс з методом оновлення. 
- Конкретний Спостерігач (ConcreteObserver): реалізує оновлення стану.СпівпрацяВидавець зберігає список Спостерігачів і викликає їх методи оновлення при зміні стану. Спостерігачі отримують оновлення і реагують відповідно.Наслідки- Забезпечує слабке зв’язування між об’єктами. 
- Підвищує гнучкість і розширюваність системи. 
- Може ускладнити відлагодження через розподілену природу оновлень. 
- Можливі проблеми з продуктивністю при великій кількості сповіщень.Приклад реалізаціїНаведено нижче (спрощений код на Java).
     Код C# – Система сповіщення погоди з патерном "Спостерігач"
 1  using System;
 2  using System.Collections.Generic;
 3  
 4  // Інтерфейс Спостерігача
 5  interface IObserver
 6  {
 7    void Update(float temperature, float humidity, float pressure);
 8  }
 9  
10  // Інтерфейс Видавця (Subject)
11  interface ISubject
12  {
13    void RegisterObserver(IObserver observer);
14    void RemoveObserver(IObserver observer);
15    void NotifyObservers();
16  }
17  
18  // Конкретний Видавець - Станція погоди
19  class WeatherStation : ISubject
20  {
21    private List<IObserver> observers;
22    private float temperature;
23    private float humidity;
24    private float pressure;
25  
26    public WeatherStation()
27    {
28      observers = new List<IObserver>();
29    }
30  
31    public void SetMeasurements(float temp, float hum, float pres)
32    {
33      temperature = temp;
34      humidity = hum;
35      pressure = pres;
36      NotifyObservers();
37    }
38  
39    public void RegisterObserver(IObserver observer)
40    {
41      observers.Add(observer);
42    }
43  
44    public void RemoveObserver(IObserver observer)
45    {
46      observers.Remove(observer);
47    }
48  
49    public void NotifyObservers()
50    {
51      foreach (var observer in observers)
52      {
53        observer.Update(temperature, humidity, pressure);
54      }
55    }
56  }
57  
58  // Конкретний Спостерігач - Поточний дисплей
59  class CurrentConditionsDisplay : IObserver
60  {
61    private float temperature;
62    private float humidity;
63  
64    public void Update(float temperature, float humidity, float pressure)
65    {
66      this.temperature = temperature;
67      this.humidity = humidity;
68      Display();
69    }
70  
71    public void Display()
72    {
73      Console.WriteLine($"Поточні умови: {temperature}°C, {humidity}% вологості");
74    }
75  }
76  
77  // Інший Спостерігач - Прогноз погоди
78  class ForecastDisplay : IObserver
79  {
80    private float currentPressure = 1013.25f;
81    private float lastPressure;
82  
83    public void Update(float temperature, float humidity, float pressure)
84    {
85      lastPressure = currentPressure;
86      currentPressure = pressure;
87      Display();
88    }
89  
90    public void Display()
91    {
92      Console.Write("Прогноз: ");
93      if (currentPressure > lastPressure)
94      {
95        Console.WriteLine("Очікується покращення погоди.");
96      }
97      else if (currentPressure == lastPressure)
98      {
99        Console.WriteLine("Без змін.");
100      }
101     else
102     {
103       Console.WriteLine("Можливе погіршення погоди.");
104     }
105   }
106 }
107 
108 // Головна програма
109 class Program
110 {
111   static void Main()
112   {
113     WeatherStation station = new WeatherStation();
114 
115     CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay();
116     ForecastDisplay forecastDisplay = new ForecastDisplay();
117 
118     station.RegisterObserver(currentDisplay);
119     station.RegisterObserver(forecastDisplay);
120 
121     Console.WriteLine("Оновлення 1:");
122     station.SetMeasurements(25.0f, 65.0f, 1012.5f);
123 
124     Console.WriteLine("\nОновлення 2:");
125     station.SetMeasurements(27.0f, 70.0f, 1015.0f);
126 
127     Console.WriteLine("\nОновлення 3:");
128     station.SetMeasurements(22.5f, 90.0f, 1009.0f);
129   }
130 }
     
     Наведений код реалізує патерн проектування "Спостерігач" (Observer) на мові програмування C# із застосуванням інтерфейсів та класів, що демонструє взаємодію між об’єктом-видавцем (станцією погоди) та кількома спостерігачами (дисплеями).
     1. Інтерфейс Спостерігача (IObserver)
     Інтерфейс IObserver визначає контракт для об’єктів-спостерігачів, які бажають отримувати оновлення про зміну стану Видавця. Метод Update приймає параметри, що відображають актуальні показники погоди: температуру, вологість та атмосферний тиск.
     2. Інтерфейс Видавця (ISubject)
     Інтерфейс ISubject визначає методи для управління списком спостерігачів:
     • RegisterObserver - реєстрація нового спостерігача для отримання оновлень.
     • RemoveObserver - видалення спостерігача зі списку.
     • NotifyObservers - сповіщення усіх зареєстрованих спостерігачів про зміну стану.
     3. Конкретний Видавець - клас WeatherStation
     Клас WeatherStation реалізує інтерфейс ISubject та виконує функції Видавця:
     • Зберігає список спостерігачів у колекції observers.
     • Метод SetMeasurements встановлює нові значення показників погоди та викликає метод NotifyObservers для інформування спостерігачів.
     • Методи RegisterObserver та RemoveObserver забезпечують динамічне додавання і видалення спостерігачів.
     • Метод NotifyObservers проходить по списку спостерігачів і викликає у кожного метод Update, передаючи актуальні дані.
     4. Конкретні Спостерігачі
     Клас CurrentConditionsDisplay:
     Цей клас реалізує інтерфейс IObserver і служить для відображення поточних погодних умов. Метод Update оновлює внутрішній стан об’єкта (температуру та вологість) і викликає метод Display, який виводить інформацію на екран.
     Клас ForecastDisplay:
     Цей спостерігач відстежує зміни атмосферного тиску для прогнозування погоди. При отриманні оновлення зберігає попереднє та поточне значення тиску і виводить прогноз на основі порівняння цих значень.
     5. Головна програма
     У методі Main створюється об’єкт Видавця WeatherStation та два Спостерігачі: CurrentConditionsDisplay і ForecastDisplay. Спостерігачі реєструються у Видавця через виклики RegisterObserver. Після цього імітується кілька оновлень погодних даних методом SetMeasurements, що призводить до автоматичного сповіщення і оновлення усіх зареєстрованих спостерігачів.
     Загальний опис роботи коду:
     • Видавець (станція погоди) зберігає список спостерігачів, які підписалися на отримання інформації про зміни.
     • При зміні погодних показників Видавець викликає метод NotifyObservers, який проходить по списку спостерігачів і викликає у кожного метод Update, передаючи актуальні дані.
     • Спостерігачі отримують оновлення, оновлюють свій внутрішній стан і виконують відповідні дії (наприклад, виводять інформацію на екран).
     • Така архітектура забезпечує слабке зв’язування між компонентами, гнучкість та можливість динамічного додавання або видалення спостерігачів без зміни коду Видавця.

4 ВИСНОВКИ


     У результаті проведеного дослідження патерну проєктування "Спостерігач" (Observer) можна зробити низку важливих висновків, що відображають його теоретичні основи, практичне застосування та вплив на архітектуру програмного забезпечення.
     Патерн "Спостерігач" є одним із ключових поведінкових патернів, який забезпечує ефективний механізм організації взаємодії між об’єктами за принципом "один до багатьох". Він дозволяє одному об’єкту (Видавцю) інформувати множину залежних об’єктів (Спостерігачів) про зміну свого стану без жорстких зв’язків між ними. Це сприяє підвищенню гнучкості, розширюваності та підтримуваності програмних систем.
     Переваги патерну:
     • Слабке зв’язування між компонентами. Завдяки використанню абстрактних інтерфейсів Видавець і Спостерігачі не залежать від конкретних реалізацій один одного. Це дозволяє легко додавати, змінювати або видаляти компоненти без необхідності модифікувати інші частини системи.
     • Автоматизація процесу оновлення. Патерн забезпечує автоматичне сповіщення всіх зацікавлених об’єктів про зміни стану Видавця, що виключає потребу у ручному опитуванні або синхронізації. Це підвищує ефективність та узгодженість даних.
     • Гнучкість і масштабованість. Можливість динамічно додавати або видаляти Спостерігачів під час виконання програми робить систему більш адаптивною до змін вимог і навантажень.
     • Широке застосування у різних сферах. Патерн ефективно використовується у графічних інтерфейсах, подієво-орієнтованому програмуванні, системах обміну повідомленнями та розподілених системах, що підтверджує його універсальність.
     Недоліки та обмеження:
     • Ризик надмірного сповіщення. У випадках великої кількості Спостерігачів або частих змін стану Видавця може виникати значне навантаження на систему, що впливає на продуктивність.
     • Потенційні циклічні залежності. Якщо Спостерігачі змінюють стан Видавця у відповідь на оновлення, це може призводити до нескінченних циклів сповіщення, що ускладнює контроль за поведінкою системи.
     • Відсутність контролю порядку оновлення. Патерн не гарантує порядок виклику методів оновлення у Спостерігачів, що може бути критично у деяких випадках, наприклад, при послідовній обробці подій.
     • Ускладнення відлагодження. Розподілена природа оновлень і слабке зв’язування компонентів ускладнюють процес відстеження джерела змін і пошук помилок.
     Патерн "Спостерігач" є важливим інструментом для розробників програмного забезпечення, оскільки дозволяє організувати ефективну комунікацію між компонентами системи, зменшуючи залежності і підвищуючи модульність. Його застосування сприяє створенню більш гнучких і підтримуваних архітектур, що відповідають сучасним вимогам до програмних продуктів.
     Отже, патерн проектування "Спостерігач" є потужним засобом організації взаємодії між об’єктами, що широко застосовується в сучасному програмному забезпеченні. Його правильне використання дозволяє підвищити якість, гнучкість та надійність розроблюваних систем.








ДОДАТОК А
     Відеозапис доповіді на YouTube: https://youtu.be/d09EQyrDxvM
     00:00 Вступ. 
     00:43 Аналіз концептуальних основ патерну. 
     01:11 Структурні компоненти патерну. 
     01:56 Порівняння з альтернативними назвами патерну. 
     02:53 Практичне застосування патерну "Спостерігач". 
     04:02 Переваги використання патерну "Спостерігач". 
     04:28 Недоліки використання патерну "Спостерігач". 
     04:58 Типові сценарії використання шаблону "Спостерігач" у програмному забезпеченні. 
     07:05 Висновок.


















ДОДАТОК Б


Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Про патерн проєктування «Спостерігач»


Рисунок Б.3 – Аналіз концептуальних основ патерну


Рисунок Б.4 – Структурні компоненти патерну


Рисунок Б.5 – Порівняння з альтернативними назвами патерну


Рисунок Б.6 – Практичне застосування патерну


Рисунок Б.7 – Переваги використання патерна «Спостерігач»


Рисунок Б.8 – Недоліки використання патерна «Спостерігач»


Рисунок Б.9 – Типові сценарії використання шаблону Observer у програмному забезпеченні


Рисунок Б.10 – Висновок




ДОДАТОК В


     Код C# – Система сповіщення погоди з патерном "Спостерігач"
 1  using System;
 2  using System.Collections.Generic;
 3  
 4  // Інтерфейс Спостерігача
 5  interface IObserver
 6  {
 7    void Update(float temperature, float humidity, float pressure);
 8  }
 9  
10  // Інтерфейс Видавця (Subject)
11  interface ISubject
12  {
13    void RegisterObserver(IObserver observer);
14    void RemoveObserver(IObserver observer);
15    void NotifyObservers();
16  }
17  
18  // Конкретний Видавець - Станція погоди
19  class WeatherStation : ISubject
20  {
21    private List<IObserver> observers;
22    private float temperature;
23    private float humidity;
24    private float pressure;
25  
26    public WeatherStation()
27    {
28      observers = new List<IObserver>();
29    }
30  
31    public void SetMeasurements(float temp, float hum, float pres)
32    {
33      temperature = temp;
34      humidity = hum;
35      pressure = pres;
36      NotifyObservers();
37    }
38  
39    public void RegisterObserver(IObserver observer)
40    {
41      observers.Add(observer);
42    }
43  
44    public void RemoveObserver(IObserver observer)
45    {
46      observers.Remove(observer);
47    }
48  
49    public void NotifyObservers()
50    {
51      foreach (var observer in observers)
52      {
53        observer.Update(temperature, humidity, pressure);
54      }
55    }
56  }
57  
58  // Конкретний Спостерігач - Поточний дисплей
59  class CurrentConditionsDisplay : IObserver
60  {
61    private float temperature;
62    private float humidity;
63  
64    public void Update(float temperature, float humidity, float pressure)
65    {
66      this.temperature = temperature;
67      this.humidity = humidity;
68      Display();
69    }
70  
71    public void Display()
72    {
73      Console.WriteLine($"Поточні умови: {temperature}°C, {humidity}% вологості");
74    }
75  }
76  
77  // Інший Спостерігач - Прогноз погоди
78  class ForecastDisplay : IObserver
79  {
80    private float currentPressure = 1013.25f;
81    private float lastPressure;
82  
83    public void Update(float temperature, float humidity, float pressure)
84    {
85      lastPressure = currentPressure;
86      currentPressure = pressure;
87      Display();
88    }
89  
90    public void Display()
91    {
92      Console.Write("Прогноз: ");
93      if (currentPressure > lastPressure)
94      {
95        Console.WriteLine("Очікується покращення погоди.");
96      }
97      else if (currentPressure == lastPressure)
98      {
99        Console.WriteLine("Без змін.");
100      }
101     else
102     {
103       Console.WriteLine("Можливе погіршення погоди.");
104     }
105   }
106 }
107 
108 // Головна програма
109 class Program
110 {
111   static void Main()
112   {
113     WeatherStation station = new WeatherStation();
114 
115     CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay();
116     ForecastDisplay forecastDisplay = new ForecastDisplay();
117 
118     station.RegisterObserver(currentDisplay);
119     station.RegisterObserver(forecastDisplay);
120 
121     Console.WriteLine("Оновлення 1:");
122     station.SetMeasurements(25.0f, 65.0f, 1012.5f);
123 
124     Console.WriteLine("\nОновлення 2:");
125     station.SetMeasurements(27.0f, 70.0f, 1015.0f);
126 
127     Console.WriteLine("\nОновлення 3:");
128     station.SetMeasurements(22.5f, 90.0f, 1009.0f);
129   }
130 }
     
