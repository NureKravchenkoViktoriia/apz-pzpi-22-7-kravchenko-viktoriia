МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 


Кафедра «Програмна інженерія»
 



ЗВІТ
з лабораторної роботи №2
з дисципліни «Архітектура програмного забезпечення»
на тему «РОЗРОБКА ПРОГРАМНОЇ АРХІТЕКТУРИ, СТВОРЕННЯ ТА ВІДЛАГОДЖЕННЯ ПРОГРАМНОГО КОДУ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ»
 



 
Виконала:                                                           	              	Прийняв:
ст. гр. ПЗПІ-22-7                                    	       	     		Сокорчук І.П.
Кравченко В. А.





Харків 2025
1 ІСТОРІЯ ЗМІН


№ДатаВерсія звітуОпис змін та виправлень126.05.20250.1Створено розділ «Історія змін», «Завдання»227.05.20250.1Створено розділ «Опис виконаної роботи»329.05.20250.1Створено «Додаток А», закінчено розділ «Додаток Б», «Додаток В» та «Висновки»     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
2 ЗАВДАННЯ

     Метою цієї лабораторної роботи є проєктування, реалізація та тестування архітектури серверної частини програмної системи для контролю споживання води у приміщенні, яка підтримуватиме взаємодію з клієнтськими додатками (десктопним, веб та мобільним) через API. Особлива увага приділяється формуванню повноцінного звіту, що містить опис прийнятих інженерних рішень, структури серверних компонентів та підсистем, а також специфікацій взаємодії.
     Звіт повинен містити такі елементи:
     • UML діаграму розгортання (Deployment Diagram); 
     • UML діаграму прецедентів (Use Case Diagram); 
     • ER-модель даних (діаграми) (Entity–Relationship Model). 
     • UML діаграму взаємодії (Interaction Overview Diagram); 
     • UML діаграму діяльності (Activity Diagram); 
     Опис програмної архітектури програмної системи та архітектуру її серверної частини. Математичні методи обробки користувацьких даних для реалізації бізнес логіки програмної системи. Математичні методи для обробки користувацьких даних у серверній частині програмної системи. ER-модель даних програмної системи та структуру БД. Специфікацію REST або іншого вибраного вами методу взаємодії програмних компонент програмної системи. Використані у серверній частині програмної системи програмні технології та компоненти. Способи інтерналізації у серверній частині програмної системи. Програмну реалізацію серверної частини програмної системи. Етапи функціонального тестування створеної серверної частини програмної системи.




3 ОПИС ВИКОНАНОЇ РОБОТИ


     В ході лабораторної роботи буде розроблено: база даних для серверної частини програмної системи для контролю споживання води у приміщенні та прикладного програмного інтерфейсу(API), бізнес-логику та функції адміністрування серверної частини  програмної системи.
     Будова програмної системи AquaTrack:
1. Фронтенд:
     WinForms:
Мова програмування: C#.
Інструмент розробки: Microsoft Visual Studio.
     Для реалізації вебінтерфейсу буде використано фреймворк React.js, який дозволить створити сучасний, адаптивний та динамічний інтерфейс користувача для доступу до функціоналу AquaTrack через браузер. Комунікація з серверною частиною буде забезпечена через REST API.
     Для створення мобільного застосунку буде використано Kotlin для платформи Android, що дозволить реалізувати нативний мобільний інтерфейс із доступом до функцій системи в зручному форматі. Обмін даними з сервером також здійснюватиметься через REST API.
Функціонал:
     • Графічний інтерфейс для перегляду поточного споживання води.
     • Таблиці для відображення історії використання води.
     • Форми для встановлення лімітів.
     • Адміністративні інструменти: додавання/видалення IoT-пристроїв, управління користувачами.
     • Двомовна локалізація інтерфейсу (українська та англійська мови).
     • Відправка сповіщень.
     2. Серверна частина (Back-end)
     Технології: C#, .NET Framework. ASP.NET для створення REST API.
     Функціонал: API для отримання та запису даних із бази даних. Валідація даних і бізнес-логіка для роботи з користувачами, лімітами та пристроями. Обробка запитів від WinForms-додатка.
     3. База даних (SQL Server)
Інструмент: Microsoft SQL Server Management Studio 19.
Таблиці:
     • User: зберігає інформацію про користувачів системи.
     • IoT Device: зберігає інформацію про IoT-пристрої.
     • WaterUsage: записує дані про споживання води.
     • Limit: містить інформацію про ліміти, встановлені користувачами.
Зв’язки:
     • User → Limit (1:Б).
     • IoT Device → WaterUsage (1:Б).
     • IoT Device → Limit (1:Б).
     4. IoT застосунок
     Функціонал:
     Збір даних із сенсорів і передача їх на сервер через REST API. Відправлення сповіщень про перевищення лімітів. Протоколи передачі даних: HTTP або MQTT.
     5. API
     Тип: REST API. Маршрути:
     /api/water-usage:
     GET /current — отримання поточних показників.
     GET /history — отримання історії використання води.
     /api/limits:
     POST /create — створення нового ліміту.
     PUT /update/{limit_id} — оновлення ліміту.
     DELETE /delete/{limit_id} — видалення ліміту.
     /api/iot-devices:
     GET /list — список пристроїв.
     POST /register — реєстрація нового пристрою.
     DELETE /delete/{device _id} — видалення ліміту.
     /api/users:
     POST /register — реєстрація нового користувача.
     POST /login — авторизація.
     PUT /update-profile — оновлення профілю.
     GET /list — отримати список користувачів (тільки адміністратор).
     Мова розробки: C#, ASP.NET Core.
     6. Модуль безпеки
Захист даних:
• Хешування паролів (наприклад, через BCrypt).
• Шифрування конфіденційних даних.
Ролі доступу:
• Адміністратор — управління користувачами та системними налаштуваннями.
• Користувач — перегляд даних і встановлення лімітів.
Валідація:
• На рівні API — перевірка коректності даних, переданих із WinForms-додатку.

     Створимо UML діаграму прецедентів для серверної частини системи (рис.1). 
     Визначення основних акторів системи:
     Актори — це об'єкти або особи, які взаємодіють із системою. У нашому випадку:
Користувач:
     • Стандартний користувач системи.
     • Має доступ до інформації про споживання води, історії, встановлення лімітів тощо.
Адміністратор:
     • Керує користувачами та їх правами доступу.
     • Здійснює адміністрування даних, резервне копіювання.
IoT-пристрій:
     • Надсилає дані про споживання води до серверної частини.
     Визначення прецедентів (Use Cases):
     Прецеденти відповідають функціоналу системи. Основні сценарії взаємодії:
Для користувача:
     • Авторизація та аутентифікація.
     • Перегляд актуальних показників водоспоживання.
     • Перегляд історії споживання води.
     • Встановлення/редагування лімітів.
     • Отримання сповіщень.
Для адміністратора:
     • Авторизація та аутентифікація.
     • Управління користувачами (додавання, блокування, видалення).
     • Управління даними системи (перегляд і налаштування параметрів).
     • Підтримка мов та різних форматів дат.
     • Виконання резервного копіювання та відновлення даних.
Для IoT-пристрою:
     • Надсилання даних про споживання води.


   Рисунок 1 - UML діаграма прецедентів для серверної частини системи.
   
     Створення UML-діаграми діяльності для серверної частини проєкту AquaTrack потребує детального опису процесів, які система виконує для роботи з даними про водоспоживання. Розглянемо процес отримання історії водоспоживання з фільтрацією за пристроєм і періодом.
     Кроки для створення UML-діаграми діяльності:
     Діаграма діяльності складається з елементів, що відображають основні етапи виконання завдань: початкові/кінцеві точки, дії, рішення, потоки і об'єкти.
     Опис дій для серверної частини включає:
     1. Прийняття HTTP-запиту клієнта.
     2. Передача запиту в контролер.
     3. Виконання бізнес-логіки (сервіс).
     4. Звернення до бази даних через репозиторій.
     5. Обробка даних і повернення відповіді клієнту.
     Основний процес:
     1. Прийом HTTP-запиту:
     • Користувач через клієнт (наприклад, веб-додаток) надсилає запит до API.
     • Запит може містити параметри deviceId, startDate, endDate для фільтрації.
     2. Обробка у контролері:
     • Контролер отримує параметри із запиту.
     • Передає параметри в сервіс для виконання бізнес-логіки.
     3. Виконання бізнес-логіки:
     • Сервіс виконує перевірку параметрів (наприклад, чи всі поля заповнені).
     • Формує фільтри для пошуку в базі даних.
     4. Отримання даних з бази даних через репозиторій:
     • Сервіс передає сформовані фільтри в репозиторій.
     • Репозиторій звертається до бази даних і виконує запит для отримання відповідних записів.
     5. Обробка результатів і повернення:
     • Сервіс обробляє отримані дані (наприклад, сортує за датою).
     • Повертає їх у контролер.
     • Контролер формує HTTP-відповідь і відправляє клієнту.
     Елементи для UML-діаграми діяльності:
     1. Початок процесу:
     • Початкова точка.
     2. Дії:
     • Користувач надсилає запит.
     • Контролер отримує і перевіряє запит.
     • Сервіс обробляє параметри.
     • Репозиторій виконує запит до бази даних.
     • Сервіс обробляє дані.
     • Контролер формує відповідь.
     3. Рішення:
     • Перевірка, чи запит містить необхідні параметри.
     • Перевірка, чи знайдено записи у базі даних.
     4. Потоки:
     • Потік між користувачем і сервером.
     • Потік між контролером, сервісом і репозиторієм.
     5. Кінцеві точки:
     • Успішне повернення результатів.
     • Повернення помилки (наприклад, якщо даних не знайдено).
     Текстовий опис процесу для UML:
     1. Початкова точка → Користувач надсилає HTTP-запит (/api/water-usage/history) з параметрами deviceId, startDate, endDate.
     2. Дія: контролер отримує запит і передає параметри в сервіс.
     3. Рішення: перевірка, чи параметри заповнені. 
     • Якщо ні: відправити відповідь «400 Bad Request».
     • Якщо так: продовжити.
     4. Дія: сервіс формує фільтри.
     5. Дія: репозиторій виконує запит до бази даних.
     6. Рішення: чи знайдено записи? 
     • Якщо ні: відправити відповідь «404 Not Found».
     • Якщо так: продовжити.
     7. Дія: сервіс обробляє дані (сортує, додає додаткові поля).
     8. Дія: контролер формує HTTP-відповідь.
     9. Кінцева точка: відправка відповіді клієнту.

Рисунок 2 – UML діаграма діяльності для серверної частини.

     UML Діаграма Взаємодії для Серверної Частини AquaTrack:
     Діаграма взаємодії показує, як об'єкти та компоненти серверної частини взаємодіють між собою для виконання певної задачі. Детальний опис, як це виглядатиме для функціоналу «Перегляд історії водоспоживання»:
     Основні Об’єкти (учасники взаємодії):
     1. Клієнт: веб-додаток або мобільний застосунок, який надсилає HTTP-запит.
     2. Контролер (WaterUsageController): приймає запит від клієнта та викликає відповідний сервіс.
     3. Сервіс (WaterUsageService): виконує бізнес-логіку, такі як фільтрація даних, перевірка параметрів тощо.
     4. Репозиторій (WaterUsageRepository): отримує дані з бази даних.
     5. База даних (Database): містить таблиці, такі як WaterUsages.
     Опис взаємодії:
     1. Клієнт відправляє запит:
     • Клієнт надсилає HTTP GET запит на api/water-usage/history для отримання історії водоспоживання.
     • Дані у запиті: параметри: deviceId, startDate, endDate (можливо, необов'язкові).
     2. Контролер отримує запит:
     • WaterUsageController викликає метод GetHistory() у WaterUsageService.
     • Передає параметри (якщо вони є) до сервісу.
     3. Сервіс обробляє дані:
     • WaterUsageService перевіряє передані параметри:
     o Якщо параметри відсутні, фільтрує всі записи за замовчуванням.
     o Якщо параметри присутні, створює фільтри для запиту до репозиторію.
     • Викликає метод GetAll() або спеціальний метод з умовами у WaterUsageRepository.
     4. Репозиторій звертається до бази даних:
     • WaterUsageRepository формує SQL-запит відповідно до отриманих фільтрів.
     • Надсилає запит до бази даних (таблиця WaterUsages).
     • Отримує результати (список записів про водоспоживання).
     5. Сервіс обробляє результати:
     • WaterUsageService отримує дані від репозиторію.
     • Сортує їх, форматує за потреби (наприклад, групує за датами або пристроями).
     • Повертає оброблений результат контролеру.
     6. Контролер формує відповідь:
     • WaterUsageController перетворює дані у формат JSON.
     • Повертає результат клієнту з відповідним HTTP статус-кодом.
     7. Клієнт отримує відповідь:
     • Клієнт отримує JSON-відповідь та відображає історію водоспоживання у вигляді графіків, таблиць тощо.

Рисунок 3 – UML діаграма взаємодії для серверної частини.
   
     Створюємо UML діаграму розгортання (Deployment Diagram) для програмної системи AquaTrack, яка контролює споживання води у приміщенні. Ця діаграма покаже, як компоненти програмної системи розгортаються на фізичних або віртуальних пристроях/вузлах і як вони взаємодіють між собою.
     1. Компоненти системи:
     Клієнтські компоненти:
     • WinForms клієнт (десктоп) – для адміністраторів і користувачів.
     • React вебінтерфейс – доступ через браузер.
     • Android мобільний застосунок (Kotlin) – для мобільного доступу.
     • IoT пристрій – відправляє дані про споживання води.
     Серверні компоненти:
     • REST API (на .NET) – обробляє запити від усіх клієнтів.
     • Бізнес-логіка – C# (.NET Framework).
     • Entity Framework ORM – зв’язує бізнес-логіку з базою даних.
     • База даних SQL Server – зберігає всі дані (споживання води, акаунти, ліміти тощо).
     2. Вузли (Nodes):
     1. Client Device (Windows PC)
     • Запускає WinForms додаток
     • Встановлено .NET Framework
     2. Web Browser (Browser)
     • Завантажує React SPA
     • Взаємодіє з сервером через REST API
     3. Mobile Device (Android)
     • Запускає Kotlin додаток
     • Взаємодіє з сервером через REST API
     4. IoT Device
     • Відправляє дані споживання на сервер (наприклад, через HTTP або MQTT)
     5. Application Server
     • Хостинг .NET додатку (бізнес-логіка, REST API)
     • Встановлено:
     o .NET Framework Runtime
     o Web Server (IIS або Kestrel)
     o Entity Framework
     6. Database Server
     • SQL Server
     • MS SQL Server Management Studio

Рисунок 4 – UML діаграму розгортання (Deployment Diagram)

     Щоб створити ER-діаграму (рис.5) для системи «AquaTrack», потрібно визначити основні сутності, їх атрибути та взаємозв'язки. 
     Сутності:
     1.User (Користувач):
     Атрибути:
• user_id (PK) — унікальний ідентифікатор користувача.
• username — ім'я користувача.
• email — електронна пошта.
• password_hash — захищений хеш пароля.
• role — роль (користувач, адміністратор).
     2.WaterUsage (Споживання води):
     Атрибути:
• usage_id (PK) — унікальний ідентифікатор запису.
• device_id (FK) — зовнішній ключ, зв'язок із IoT-пристроєм.
• usage_value — кількість спожитої води (у літрах або іншій одиниці).
• timestamp — дата та час вимірювання.
     3.IoT Device (IoT-пристрій):
     Атрибути:
• device_id (PK) — унікальний ідентифікатор пристрою.
• device_type — тип пристрою (наприклад, водомір, датчик витрати).
• status — статус пристрою (активний/неактивний).
• limit_id(FK)
     4.Limit (Ліміт на споживання):
     Атрибути:
• limit_id (PK) — унікальний ідентифікатор ліміту.
• limit_value — максимальне значення споживання води.
• start_date — дата початку дії ліміту.
• end_date — дата закінчення дії ліміту.
• user_id(FK)
     
     Взаємозв’язки між сутностями:
     1.IoT Device (IoT-пристрій) — WaterUsage (Споживання води):
     Тип зв’язку: один до багатьох (1:Б)
     Опис: один IoT-пристрій може передавати багато записів про споживання води.
     2.User (Користувач) — Limit (Ліміт на споживання):
     Тип зв’язку: один до багатьох (1:Б)
     Опис: один користувач може встановити кілька лімітів на різний період часу.
     3. IoT Device (IoT-пристрій) —  Limit (Ліміт на споживання):
     Тип зв’язку: один до багатьох (1:Б).
     Опис: багато лімітів може бути прив’язано до одного пристрою(один ліміт на один період часу, інший – на інший період).
     

Рисунок 5 – ER діаграма даних.
     
     Розробимо базу даних програмної системи в MS SQL Server. Створюємо таблиці відповідно до ER діаграми на мові SQL(див. додаток В).
     1. Таблиця Users:
     • Зберігає інформацію про користувачів.
     • Унікальний user_id для ідентифікації.
     • Поле role дозволяє визначати доступ користувача до функцій системи.
     2. Таблиця IoT_Device:
     • Кожен пристрій має унікальний device_id.
     • Поле status вказує, чи пристрій активний.
     3. Таблиця Limits:
     • Пов’язана із таблицями Users та IoT_Device.
     • Поле user_id вказує, хто встановив ліміт.
     • Поле device_id вказує, до якого пристрою прив’язаний ліміт.
     • Один пристрій може мати багато лімітів на різні періоди часу.
     4. Таблиця WaterUsage:
     • Зберігає записи про споживання води для пристроїв.
     • Поле device_id забезпечує зв’язок із конкретним пристроєм.
     Взаємозв’язки
     1. IoT_Device → WaterUsage (1:Б): один пристрій може передавати багато записів про споживання води.
     2. Users → Limits (1:Б): один користувач може встановити кілька лімітів.
     3. IoT_Device → Limits (1:Б): один пристрій може мати кілька лімітів, застосованих на різні періоди часу.

     Створимо діаграму структури бази даних у MS SQL Server (рис.6).
     

Рисунок 6 – діаграма структури бази даних.
     
     Створимо функції роботи з базою даних у WinForms із використанням Entity Framework як ORM. Працюємо в C# у середовищі Microsoft Visual Studio, і база даних вже створена. Додамо бібліотеку Entity Framework через NuGet Package Manager.
     Далі додаємо рядок підключення у файл App.config:
	<connectionStrings>
		<add name="DefaultConnection"
			 connectionString="Server=DESKTOP-7G3I2IS;Database=aquatrack;Trusted_Connection=True;"
			 providerName="System.Data.SqlClient" />
	</connectionStrings>
     
     Створюємо моделі для таблиць: у папці Data створимо папку Models та для кожної таблиці клас:
     Модель для таблиці Users:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AquaTrack.Data.Models
{
    public class User
    {
        public int UserId { get; set; }
        public string Username { get; set; }
        public string Email { get; set; }
        public string PasswordHash { get; set; }
        public string Role { get; set; }
    }
}
     
     Аналогічно для інших таблиць.
     Створимо репозиторії для CRUD-функцій: створюємо папку Repositories та базовий інтерфейс IRepository.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AquaTrack.Repositories
{
    public interface IRepository<T> where T : class
    {
        IEnumerable<T> GetAll();
        T GetById(int id);
        void Add(T entity);
        void Update(T entity);
        void Delete(int id);
    }
}
     
     Створимо клас для роботи з користувачами UserRepository.cs та аналогічно створимо репозиторії для інших таблиць (див. додаток).
     
     Опис інженерних рішень:
     Серверна частина: ASP.NET Web API використовується як основний інструмент для створення RESTful API, який забезпечує зв’язок між клієнтською частиною (веб-інтерфейсом або додатками) і серверною логікою. Ця технологія обрана завдяки її гнучкості, легкості налаштування та інтеграції з іншими компонентами .NET.
     Переваги вибору:
     • Зручна робота з HTTP-запитами (GET, POST, PUT, DELETE).
     • Підтримка атрибутного маршрутизації для організації чіткої структури API.
     • Інтеграція зі сторонніми бібліотеками, як-от Swagger для документування API.
     База даних: SQL Server з використанням ORM Entity Framework
SQL Server обрано як СУБД для зберігання даних через його продуктивність, надійність і можливість роботи з великими обсягами інформації.
     Entity Framework (EF) використовується як ORM (Object-Relational Mapping) для зручної роботи з базою даних. EF забезпечує:
     • Можливість використовувати LINQ-запити для взаємодії з даними.
     • Автоматичну генерацію SQL-запитів.
     • Полегшену підтримку змін у схемі бази даних через міграції.
     Інтеграція DI-контейнера: Unity впроваджено для реалізації принципу інверсії залежностей (Dependency Injection, DI). Це дозволяє знизити зв’язність між компонентами системи, спрощує тестування та підтримку.
     Особливості:
     • Усі залежності між компонентами (наприклад, сервіси та репозиторії) реєструються в контейнері Unity.
     • Контролери автоматично отримують необхідні сервіси через конструктор завдяки впровадженню залежностей.
     • Застосовано HierarchicalLifetimeManager для управління життєвим циклом об'єктів і запобігання витокам пам’яті.
     Сервісний шар:
     Шар сервісів впроваджений для відокремлення бізнес-логіки від контролерів. Це покращує структуру коду, забезпечуючи:
     • Чіткий розподіл відповідальності між компонентами.
     • Легкість у тестуванні бізнес-логіки (сервіси можна тестувати окремо).
     Сервіси, реалізовані в проекті:
     UserService: реалізує функції реєстрації, авторизації, оновлення профілю користувачів та інші дії, пов’язані з користувачами.
     IoTDeviceService: здійснює управління IoT-пристроями (реєстрація, отримання статусу, оновлення даних).
     LimitService: відповідає за встановлення та контроль лімітів споживання води.
     WaterUsageService: забезпечує функціонал моніторингу споживання води.
     Кожен сервіс взаємодіє з відповідним репозиторієм, який виконує запити до бази даних.
     Репозиторії є посередниками між базою даних і сервісним шаром. Вони інкапсулюють логіку доступу до даних, що дозволяє: зменшити дублювання коду та легко змінювати логіку взаємодії з базою даних.
     Для кожної сутності створено окремий репозиторій, який реалізує базові операції:
     • GetAll: отримання всіх записів із таблиці.
     • GetById: пошук запису за ідентифікатором.
     • Add: додавання нового запису.
     • Update: оновлення існуючого запису.
     • Delete: видалення запису за ідентифікатором.
     Наприклад, UserRepository працює з таблицею Users у базі даних і забезпечує всі основні CRUD-операції для цієї сутності.
     Контролери відповідають за взаємодію серверної частини з клієнтами через API. Раніше вони напряму працювали з контекстом бази даних, що створювало складності в масштабуванні та тестуванні.
     Тепер контролери використовують сервіси для обробки запитів. Логіка контролерів спрощена, оскільки вся бізнес-логіка перенесена в сервіси. Контролери працюють лише як точка входу для HTTP-запитів.
     Приклад контролера:
     UsersController приймає запити на реєстрацію, авторизацію, оновлення профілю тощо. Кожен запит передається до відповідного методу UserService, який виконує бізнес-логіку.
     Ці інженерні рішення забезпечують гнучкість, масштабованість і легкість підтримки серверної частини системи AquaTrack.
     Специфікація API за допомогою Swagger. Щоб тестувати API маршрути за допомогою Swagger в проекті, потрібно налаштувати його для ASP.NET додатку. Swagger дає автоматично згенеровану документацію для API, а також можливість тестувати ці маршрути безпосередньо через веб-інтерфейс.
     Кроки для налаштування Swagger:
     1. Встановлення Swagger в проект:
     Для того, щоб додати Swagger, потрібно спочатку встановити необхідні NuGet пакети: Install-Package Swashbuckle.Core. Це основний пакет для інтеграції Swagger з ASP.NET Web API.
     2. Налаштування Swagger в Startup.cs
     Після встановлення пакету потрібно налаштувати Swagger. Для цього відредагуємо файл Startup.cs. Додамо простір імен для Swagger в самому верху файлу: using Swashbuckle.Application; 
     Додамо Swagger в метод Configuration:
     
// Налаштування Swagger
config.EnableSwagger(c =>
{
    	c.SingleApiVersion("v1", "AquaTrack API");
}).EnableSwaggerUi();  // Додаємо Swagger UI
     
     Це налаштує Swagger і створить веб-інтерфейс для тестування вашого API.
     3. Тестування маршрутів
     На сторінці Swagger UI побачимо всі доступні API маршрути, які описали в контролерах (рис.7, рис.8).

Рисунок 7 – документація для API Swagger.
     

Рисунок 8 – розгорнута документація для API Swagger.
     
     Тепер доступна інтерактивна документація для API, яку можна тестувати через Swagger UI. Це дуже зручний спосіб перевіряти маршрути, тестувати відповіді сервера та виявляти помилки на ранніх етапах.
     Фрагменти програмного коду включають ключові частини коду, які ілюструють основні аспекти системи.
     1. Логіка взаємодії серверної частини з БД:
     Код із репозиторіїв, які реалізують доступ до бази даних через Entity Framework. 
     Репозиторії(див. додаток): IRepository.cs, UserRepository.cs, IoTDeviceRepository.cs, WaterUsageRepository.cs, LimitRepository.cs.
     2. Логіка взаємодії серверної частини з клієнтами:
     Код із контролерів, які обробляють запити від клієнтів і передають їх у сервіси. 
     Контролери(див. додаток): UsersController.cs, IoTDevicesController.cs, WaterUsageController.cs, LimitsController.cs.
     
     Бізнес-логіка серверної частини програмної системи «AquaTrack» – це набір правил і процедур, які забезпечують виконання функціональних вимог програми. В контексті проєкту AquaTrack бізнес-логіка повинна включати:
     Управління користувачами:
     1. Реєстрація користувачів:
     • Перевірка, чи не існує користувач із таким же email.
     • Збереження хешованого пароля для безпеки.
     • Призначення ролі за замовчуванням («User»).
     2. Авторизація користувачів:
     • Валідація введених даних (email та пароль).
     • Порівняння хешованого пароля з тим, що зберігається в базі даних.
     3. Управління профілем:
     • Зміна пароля.
     • Перевірка валідності змін (наприклад, унікальність email).
     4. Адміністративні функції
     • Видалення користувачів.
     • Перегляд списку користувачів.
     Управління IoT-пристроями:
     1. Додавання нового пристрою:
     • Перевірка, чи пристрій із таким номером вже існує.
     2. Збір даних від пристроїв:
     • Обробка отриманих даних (наприклад, обсяг використаної води).
     • Збереження даних у базу з прив'язкою до пристрою.
     3. Моніторинг стану пристроїв:
     • Генерація сповіщень.

     Управління лімітами водоспоживання:
     1. Створення лімітів:
     • Призначення максимального обсягу використаної води для певного періоду (наприклад, день, місяць).
     • Прив'язка ліміту до конкретного пристрою, користувача.
     2. Перевірка перевищення лімітів:
     • Розрахунок поточного обсягу використаної води.
     • Генерація сповіщень у разі перевищення.
     3. Статистика по лімітах:
     • Показник, наскільки використання води наближається до ліміту.
     Управління даними про використання води:
     1. Збереження даних:
     • Прийом даних про обсяг використаної води від IoT-пристроїв.
     • Прив'язка цих даних до пристрою.
     2. Аналіз даних:
     • Підрахунок середнього обсягу водоспоживання за день, місяць тощо.
     • Візуалізація статистики для клієнта.
     3. Генерація звітів:
     • Формування звітів по використанню води для адміністратора чи користувача.
     Валідація та обробка помилок:
     1. Валідація вхідних даних:
     • Перевірка наявності всіх обов’язкових полів.
     • Перевірка форматів (наприклад, email, числові значення).
     2. Обробка виключень:
     • Коректна обробка помилок бази даних (наприклад, відсутність записів).
     • Повернення клієнту зрозумілих повідомлень про помилки.
     Програмна структура бізнес-логіки:
     1. Сервісний шар (Services):
     • Включає класи для кожної основної функції (наприклад, UserService, IoTDeviceService, LimitService).
     • Виконує бізнес-логіку: обробку даних, виклики репозиторіїв, обчислення тощо.
     2. Репозиторії (Repositories):
     • Робота з базою даних (CRUD-операції).
     • Інкапсуляція взаємодії з контекстом бази даних.
     3. Контролери (Controllers):
     • Здійснюють передачу даних між клієнтом і сервісним шаром.
     • Використовують сервіси для виконання бізнес-логіки.

     Функції адміністрування серверної частини забезпечують контроль і управління ключовими ресурсами системи, такими як користувачі, пристрої, ліміти й дані про споживання води. У контексті AquaTrack, це дозволяє адміністраторам виконувати такі завдання:
     Адміністрування користувачів:
     1. Перегляд списку користувачів:
     • Функціонал: Надання адміністраторам доступу до повного списку зареєстрованих користувачів.
     • Деталі реалізації: 
     o Виклик сервісу для отримання всіх записів із таблиці Users.
     o Фільтрація за ролями.
     2. Редагування профілів:
     • Функціонал: Зміна ролі користувача.
     • Деталі реалізації: 
     o Отримання користувача за ідентифікатором.
     o Застосування змін.
     o Збереження оновленого запису.
     3. Видалення користувачів:
     • Функціонал: Видалення облікових записів, які більше не потрібні.
     • Деталі реалізації: 
     o Видалення запису із таблиці Users.
     Адміністрування IoT-пристроїв:
     1. Перегляд списку пристроїв:
     • Функціонал: Відображення повного списку підключених пристроїв із деталями.
     • Деталі реалізації: 
     o Отримання записів із таблиці IoTDevices.
     o Фільтрація за статусом (активний, неактивний).
     2. Додавання нового пристрою:
     • Функціонал: Реєстрація нового IoT-пристрою в системі.
     • Деталі реалізації: 
     o Збереження номера, статусу.
     3. Видалення пристроїв:
     • Функціонал: Видалення пристроїв, які більше не використовуються.
     • Деталі реалізації: 
     o Видалення запису із таблиці IoTDevices.
     4. Моніторинг пристроїв:
     • Функціонал: Відстеження активності пристроїв.
     • Деталі реалізації: 
     o Виведення стану пристрою.
     o Сповіщення про проблеми.
     Адміністрування лімітів:
     1. Перегляд встановлених лімітів:
     • Функціонал: Перегляд поточних лімітів для водоспоживання.
     • Деталі реалізації: 
     o Отримання даних із таблиці Limits.
     o Відображення лімітів, прив’язаних до пристроїв або користувачів.
     2. Додавання нового ліміту:
     • Функціонал: Встановлення нового обмеження для водоспоживання.
     • Деталі реалізації: 
     o Валідація введених даних (значення ліміту, період дії тощо).
     o Збереження ліміту в базу даних.
     3. Оновлення існуючих лімітів:
     • Функціонал: Зміна поточних обмежень.
     • Деталі реалізації: 
     o Отримання ліміту за ідентифікатором.
     o Застосування нових параметрів.
     o Збереження зміненого запису.
     4. Видалення лімітів:
     • Функціонал: Видалення застарілих або непотрібних лімітів.
     • Деталі реалізації: 
     o Перевірка, чи є залежності (історія використання).
     o Видалення запису.
     Управління даними про використання води:
     1. Перегляд історії водоспоживання:
     • Функціонал: Надання доступу до історичних даних про використання води.
     • Деталі реалізації: 
     o Отримання даних із таблиці WaterUsages.
     o Фільтрація за пристроями або періодом.
     2. Генерація звітів:
     • Функціонал: Формування звітів по використанню води.
     • Деталі реалізації: 
     o Обробка даних із таблиці WaterUsages.
     o Генерація звітів у форматі PDF.
     Програмна структура для адміністрування:
     1. Контролери (Controllers):
     • Спеціалізовані контролери для користувачів, пристроїв, лімітів тощо.
     2. Сервісний шар (Services):
     • Класи: UserService, IoTDeviceService, LimitService, WaterUsageService.
     • Реалізація логіки адміністрування.
     3. Репозиторії (Repositories):
     • Класи: UserRepository, IoTDeviceRepository, LimitRepository, WaterUsageRepository.


     Реєстрація користувачів:
     Опис:
     Ця функція дозволяє створювати нових користувачів із перевіркою унікальності email, хешуванням пароля для безпеки та призначенням базової ролі «User».
     Кроки реалізації:
     1. Перевірка, чи існує користувач із таким же email:
     • Виконати пошук у базі даних за полем Email.
     • Якщо знайдено користувача, повернути відповідь із помилкою.
     2. Хешування пароля:
     • Використати бібліотеку для хешування паролів, наприклад, BCrypt.Net.
     • Хешований пароль зберігати в полі PasswordHash.
     3. Призначення ролі за замовчуванням:
     • Поле Role для нового користувача встановлюється у значення «User».
     Код методу в UserService:
        public void RegisterUser(User user)
        {
            // Перевірка, чи існує користувач із таким email
            if (_repository.GetAll().Any(u => u.Email == user.Email))
            {
                throw new Exception("Користувач із таким email вже існує.");
            }

            // Хешування пароля
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(user.PasswordHash);

            // Призначення ролі за замовчуванням
            user.Role = "User";

            // Додавання користувача до бази
            _repository.Add(user);
        }
     Код методу в UsersController:
        [HttpPost]
        [Route("register")]
        public IHttpActionResult Register(User user)
        {
            try
            {
                _service.RegisterUser(user);
                return Ok("Користувач успішно зареєстрований.");
            }
            catch (Exception ex)
            {
                return BadRequest(ex.Message);
            }
        }
     Авторизація користувачів:
     Опис:
     Функція авторизації забезпечує вхід користувача, перевіряючи введені дані (email і пароль) та порівнюючи хеш пароля.
     Кроки реалізації:
     1. Валідація введених даних:
     • Перевірка, чи не є email та пароль порожніми.
     2. Пошук користувача в базі даних за email:
     • Якщо користувача з таким email не знайдено, повернути помилку.
     3. Перевірка хешованого пароля:
     • Використати метод перевірки пароля (BCrypt.Verify).
     • Якщо пароль не збігається, повернути помилку авторизації.
     4. Успішна авторизація:
     • Повернути дані користувача (або токен, якщо використовується).
     Метод у UserService:
        public User Authenticate(string email, string password)
        {

            // Пошук користувача за email
            var user = _repository.GetAll().FirstOrDefault(u => u.Email == email);

            if (user == null)
            {
                throw new Exception("Користувача з таким email не знайдено.");
            }

            // Перевірка хешованого пароля
            if (!BCrypt.Net.BCrypt.Verify(password, user.PasswordHash))
            {
                throw new Exception("Невірний пароль.");
            }

            return user;
        } 
     Метод у UsersController:
        [HttpPost]
        [Route("login")]
        public IHttpActionResult Login(string email, string password)
        {

            try
            {
                var user = _service.Authenticate(email, password);
                return Ok(new
                {
                    Message = "Успішна авторизація",
                    UserId = user.UserId,
                    Username = user.Username,
                    Role = user.Role
                });
            }
            catch (Exception ex)
            {
                return Unauthorized(); // Неправильний логін або пароль
            }
        }
     
     Тестування:
     Реєстрація користувача:
     Відправити POST-запит до /api/users/register із даними користувача.

     Рисунок 9 – користувача успішно зареєстровано.
     
     Авторизація користувача:
     Відправити POST-запит до /api/users/login із правильними та неправильними даними.

Рисунок 10 – успішна авторизація.


Рисунок 11 – авторизація з неправильними даними.
     
     Для реалізації управління IoT-пристроями в рамках системи, а також обробки даних, отриманих від цих пристроїв, необхідно виконати наступні дії:
     Додавання нового пристрою:
     Для реєстрації IoT-пристроїв уже підготовлено метод RegisterDevice в контролері IoTDevicesController. 
     Реалізація API для додавання пристрою:
     Контролер: метод RegisterDevice приймає модель пристрою (IoTDevice) і додає її через сервіс. Реалізація вже підготовлена:
[HttpPost]
[Route("register")]
public IHttpActionResult RegisterDevice(IoTDevice device)
{
    _service.AddDevice(device);
    return Ok(device);
}
     Модель пристрою: модель IoTDevice містить такі властивості:
     • DeviceId — Унікальний ідентифікатор.
     • DeviceType — Тип пристрою.
     • Status — Статус (активний/неактивний).
     • Зв’язок із таблицею Limits.
     Логіка в сервісі: у методі AddDevice викликається відповідний метод репозиторію:
public void AddDevice(IoTDevice device)
{
    _repository.Add(device);
}

     Код сервісу WaterUsageService виглядає добре структурованим для роботи з історією використання води та додаванням нових записів. Розширимо і уточнимо його функціональність для повної реалізації збору даних від IoT-пристроїв:
     Перевірка валідності даних пристрою:
     Перед збереженням запису використання води переконаємося, що пристрій із відповідним DeviceId існує. Для цього можна додати перевірку у метод AddUsageRecord.
     Оновлений метод AddUsageRecord:
        public void AddUsageRecord(WaterUsage usage, IoTDeviceService deviceService)
        {
            // Перевірка пристрою
            var device = deviceService.GetDeviceById(usage.DeviceId);
            if (device == null)
                throw new ArgumentException($"Device with ID {usage.DeviceId} not found.");

            // Перевірка дублювання запису
            var existingRecord = _repository.GetAll()
                .FirstOrDefault(w => w.DeviceId == usage.DeviceId && w.Timestamp == usage.Timestamp);

            if (existingRecord != null)
                throw new ArgumentException("Duplicate record for the same device and timestamp.");

            // Валідація обсягу
            if (usage.UsageValue < 0)
                throw new ArgumentException("Usage value cannot be negative.");

            // Додавання запису
            _repository.Add(usage);
        } 
     Метод для збору даних від пристроїв:
     У контролері IoTDevicesController можна створити API для збору даних, який буде викликати цей метод. У сервісі WaterUsageService не потрібно суттєвих змін, оскільки вже є метод AddUsageRecord.
     Оновлений API у контролері
     Контролер:
        [HttpPost]
        [Route("collect-data")]
        public IHttpActionResult CollectData(WaterUsage data)
        {
            try
            {
                _waterUsageService.AddUsageRecord(data, _service);
                return Ok("Data collected successfully.");
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        }
     Розглянемо реалізацію функціоналу управління лімітами водоспоживання поетапно.
     Створення лімітів:
     Логіка: ліміт має містити максимальний обсяг використаної води (LimitValue), період дії (StartDate, EndDate) і бути прив’язаним до конкретного IoT-пристрою та користувача.
     Код уже готовий:
     • LimitService для роботи з лімітами.
     • LimitsController для API-запитів створення, оновлення та видалення лімітів.
     Тестування:
     Swagger: Використаємо маршрут POST /api/limits/create, щоб створити тестовий ліміт.
     При введенні некоректних даних бачимо відповідні помилки:

Рисунок 12 – Введення некоректної дати.

Рисунок 13 – Введення некоректного зачення.

     Перевірка перевищення лімітів:
     Логіка: розрахунок поточного обсягу використаної води:
     Додати всі записи з таблиці WaterUsage, які відповідають пристрою (DeviceId) та входять у період дії ліміту (StartDate, EndDate).
     Порівняння з лімітом: якщо сума перевищує LimitValue, то ліміт порушено.
     Код для перевірки. Додамо метод до LimitService:
        public bool IsLimitExceeded(int limitId)
        {
            var limit = _repository.GetById(limitId);
            if (limit == null) throw new ArgumentException("Limit not found.");

            var totalUsage = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Sum(w => w.UsageValue);

            return totalUsage > limit.LimitValue;
        } 
     API для перевірки:
     Додамо новий маршрут до LimitsController:
        [HttpGet]
        [Route("check-exceeded/{limitId}")]
        public IHttpActionResult CheckLimitExceeded(int limitId)
        {
            try
            {
                var isExceeded = _service.IsLimitExceeded(limitId);
                return Ok(new { LimitExceeded = isExceeded });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        } 
     Статистика по лімітах:
     Логіка: визначити, наскільки споживання наближається до ліміту у відсотках.
     Додамо метод до LimitService:
        public decimal GetLimitProgress(int limitId)
        {
            var limit = _repository.GetById(limitId);
            if (limit == null) throw new ArgumentException("Limit not found.");

            var totalUsage = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Sum(w => w.UsageValue);

            return (totalUsage / limit.LimitValue) * 100;
        } 
     API для статистики:
     Додамо новий маршрут до LimitsController:

        [HttpGet]
        [Route("progress/{limitId}")]
        public IHttpActionResult GetLimitProgress(int limitId)
        {
            try
            {
                var progress = _service.GetLimitProgress(limitId);
                return Ok(new { Progress = progress });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        } 
     Прийом даних про обсяг використаної води від IoT-пристроїв:
     У WaterUsageService використовуємо метод AddUsageRecord, який перевіряє пристрій, дублювання запису та валідує значення споживаної води. Це важлива частина процесу, яка гарантує правильність введених даних.
     Візуалізація статистики для клієнта:
     Щоб забезпечити візуалізацію даних для клієнта, можна реалізувати методи в WaterUsageController, які надають агреговану інформацію:
        [HttpGet]
        [Route("average-usage")]
        public IHttpActionResult GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            try
            {
                var averageUsage = _service.GetAverageUsage(deviceId, startDate, endDate);
                return Ok(averageUsage);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        } 
     Цей метод поверне середнє споживання води за вказаний період. Для подальшої візуалізації на клієнтській стороні.
     Оновлення методу GetCurrentUsage:
     Щоб зробити метод більш гнучким і додати можливість отримувати поточні дані не тільки для останнього запису, можна додати параметри для отримання поточного значення водоспоживання для певного пристрою за певний період:
        public WaterUsage GetCurrentUsage(int deviceId)
        {
            return _repository
                .GetAll()
                .Where(w => w.DeviceId == deviceId)
                .OrderByDescending(w => w.Timestamp)
                .FirstOrDefault();
        } 
     Цей метод дозволить отримувати актуальні дані для конкретного пристрою.
     Метод для визначення середнього використання за період:
     Додамо новий метод до WaterUsageService для обчислення середнього використання води за вказаний період, наприклад, день, місяць чи рік.
     Код:
        public decimal GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            var usageRecords = _repository
                .GetAll()
                .Where(w => w.DeviceId == deviceId && w.Timestamp >= startDate && w.Timestamp <= endDate)
                .ToList();

            if (!usageRecords.Any())
                throw new ArgumentException("No usage records found for the specified period.");

            // Підрахунок загального використання і середнього
            var totalUsage = usageRecords.Sum(w => w.UsageValue);
            var daysCount = (endDate - startDate).Days;

            return totalUsage / daysCount;
        } 
     Цей метод обчислює середнє використання води для певного пристрою між вказаними датами. Він підсумовує всі записи і ділить на кількість днів у вказаному періоді.
     Контролер для роботи з новими методами:
     У контролері WaterUsageController.cs потрібно додати нові маршрути для цих методів.
     Для отримання поточного використання для конкретного пристрою:
[HttpGet]
[Route("current/{deviceId}")]
public IHttpActionResult GetCurrentUsage(int deviceId)
{
var currentUsage = _service.GetCurrentUsage(deviceId);
if (currentUsage == null)
return NotFound();

return Ok(currentUsage);
        } 
     Для отримання середнього використання за період:
        [HttpGet]
        [Route("average-usage")]
        public IHttpActionResult GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            try
            {
                var averageUsage = _service.GetAverageUsage(deviceId, startDate, endDate);
                return Ok(averageUsage);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        } 
     Тепер, при виклику наступних маршрутів, можна отримувати відповідні дані:
     • GET api/water-usage/current/{deviceId} – для поточного використання для конкретного пристрою.
     • GET api/water-usage/average-usage?deviceId={deviceId}&startDate={startDate}&endDate={endDate} – для отримання середнього використання води для конкретного пристрою за період.
     Це дозволить клієнту легко отримувати актуальні дані і статистику по використанню води для певних пристроїв.
     
     Для впровадження функціоналу «Перегляд списку користувачів» в адміністративному інтерфейсі, вже маємо готові основні компоненти. Опишемо кроки реалізації:
     Контролер UsersController:
     Метод GetUsers вже реалізований для отримання списку всіх користувачів із перевіркою ролі адміністратора. Цей метод відповідає за валідацію ролі поточного користувача, виклик методу GetAllUsers сервісу UserService.
     Фільтрація за ролями:
     Для фільтрування користувачів за ролями (наприклад, «User», «Admin»), додамо можливість передавати параметри в API:
     Розширений метод з фільтром:

        [HttpGet]
        [Route("list")]
        public IHttpActionResult GetUsers(string role = null)
        {
            var currentUserRole = "Admin"; // Перевірка ролі
            if (currentUserRole != "Admin")
            {
                return Content(HttpStatusCode.Forbidden, "Доступ дозволений тільки адміністраторам.");
            }

            var users = _service.GetAllUsers();
            if (!string.IsNullOrEmpty(role))
            {
                users = users.Where(u => u.Role.Equals(role, StringComparison.OrdinalIgnoreCase));
            }

            return Ok(users);
        } 
     Сервіс UserService:
     Сервіс уже має метод GetAllUsers, який повертає список користувачів та додамо фільтрацію за роллю безпосередньо в цьому методі:
        public IEnumerable<User> GetAllUsers(string role = null)
        {
            var users = _repository.GetAll();
            if (!string.IsNullOrEmpty(role))
            {
                users = users.Where(u => u.Role.Equals(role, StringComparison.OrdinalIgnoreCase));
            }
            return users;
        }
     Цей функціонал забезпечить адміністраторам доступ до списку користувачів із можливістю фільтрації та подальшого управління.
     
     Для реалізації функціоналу «Редагування профілів: Зміна ролі користувача», необхідно виконати наступні кроки:
     Додамо метод у UsersController:
     Метод повинен приймати ID користувача і нову роль, яку потрібно призначити.
     Метод для зміни ролі:
        [HttpPut]
        [Route("update-role")]
        public IHttpActionResult UpdateRole(int userId, string newRole)
        {
            try
            {
                var user = _service.GetUserById(userId);
                if (user == null)
                {
                    return NotFound(); // Користувача не знайдено
                }

                // Перевірка нової ролі
                var validRoles = new List<string> { "User", "Admin", "Moderator" }; // Додайте ваші ролі
                if (!validRoles.Contains(newRole))
                {
                    return BadRequest("Невірна роль.");
                }

                // Оновлення ролі
                user.Role = newRole;
                _service.UpdateUser(user);

                return Ok($"Роль користувача з ID {userId} успішно змінено на {newRole}.");
            }
            catch (Exception ex)
            {
                return BadRequest($"Помилка при оновленні ролі: {ex.Message}");
            }
        } 
     Маршрут:
     PUT /api/users/update-role
     Body: { "userId": 1, "newRole": "Admin" }
     Додамо метод у UserService:
     Використаємо наявний метод UpdateUser, щоб змінювати роль користувача.
     Метод у сервісі:
        public void UpdateUserRole(int userId, string newRole)
        {
            var user = GetUserById(userId);
            if (user == null)
            {
                throw new Exception("Користувача не знайдено.");
            }

            user.Role = newRole;
            UpdateUser(user);
        } 
     Цей функціонал забезпечує базову можливість адміністрування користувачів, дозволяючи змінювати їх ролі.
     
     Для реалізації функціоналу «Видалення користувачів», необхідно додати методи до UsersController, UserService, та інтегрувати цей функціонал в WinForms.
     Додамо метод у UsersController:
     Код:
        [HttpDelete]
        [Route("delete/{id}")]
        public IHttpActionResult DeleteUser(int id)
        {
            var currentUserRole = "Admin"; // Замінити на реальну перевірку ролі

            if (currentUserRole != "Admin")
            {
                return Content(HttpStatusCode.Forbidden, "Доступ дозволений тільки адміністраторам.");
            }

            try
            {
                var user = _service.GetUserById(id);
                if (user == null)
                {
                    return NotFound();
                }

                _service.DeleteUser(id);
                return Ok($"Користувача з ID {id} успішно видалено.");
            }
            catch (Exception ex)
            {
                return BadRequest($"Помилка видалення: {ex.Message}");
            }
        }
     
     Додамо метод у UserService:
        public void DeleteUser(int id)
        {
            var user = _repository.GetById(id);
            if (user == null)
            {
                throw new Exception("Користувача з таким ID не знайдено.");
            }

            _repository.Delete(id);
        } 
     Цей функціонал забезпечує безпечне та ефективне видалення облікових записів, які більше не потрібні в системі.
     
     Для реалізації функціоналу перегляду списку IoT-пристроїв із фільтрацією за статусом, потрібно буде додати API маршрут для фільтрації пристроїв за статусом.
     В контролері IoTDevicesController додамо новий метод для отримання пристроїв із фільтрацією за статусом:
        [HttpGet]
        [Route("list-by-status")]
        public IHttpActionResult GetDevicesByStatus(string status)
        {
            var devices = _service.GetAllDevices()
                                  .Where(d => d.Status.Equals(status, StringComparison.OrdinalIgnoreCase))
                                  .ToList();

            if (!devices.Any())
                return NotFound();

            return Ok(devices);
        } 
     Цей метод прийматиме параметр status і фільтруватиме пристрої за статусом.
     
     Для реалізації функціоналу видалення IoT-пристроїв, які більше не використовуються, потрібно додати необхідний інтерфейс на клієнтській стороні та забезпечити інтеграцію з існуючим серверним методом.
     Серверна частина:
     Метод DeleteDevice у контролері IoTDevicesController вже реалізований.
     Маршрут для видалення: DELETE /api/iot-devices/delete/{deviceId}.
     Цей метод перевіряє існування пристрою за deviceId і видаляє його з бази даних.
     Результат:
     1. Користувач вибирає пристрій зі списку і натискає кнопку «Видалити».
     2. Система запитує підтвердження.
     3. Після підтвердження відправляється запит DELETE /api/iot-devices/delete/{deviceId} до сервера.
     4. Пристрій видаляється із бази даних.
     5. Список пристроїв оновлюється у клієнтському інтерфейсі.
     
     Для реалізації функціоналу моніторингу активності IoT-пристроїв (відстеження статусу активності: активний чи неактивний) потрібно забезпечити:
1. Виведення стану пристрою на клієнтській стороні.
2. Можливість періодичного оновлення статусу (опціонально, для динамічного моніторингу).
     Серверна частина:
     У контролері IoTDevicesController вже є метод GetDevices, який повертає всі пристрої з їх статусами. Статус пристрою зберігається у полі Status.
     Цей метод можна використовувати для отримання актуального статусу пристроїв.
     
     Для реалізації функціоналу перегляду встановлених лімітів водоспоживання, можна використовувати вже наявну структуру коду. 
     Серверна частина:
     У контролері LimitsController вже є методи для роботи з лімітами, зокрема для їх створення, оновлення, видалення, а також перевірки перевищення ліміту і прогресу ліміту.
     Додамо метод для отримання всіх лімітів:
        [HttpGet]
        [Route("list")]
        public IHttpActionResult GetLimits()
        {
            var limits = _service.GetAllLimits();
            return Ok(limits);
        } 
     Цей метод повертає список усіх лімітів, які є в базі даних. 
     Додаткові функції:
     Перевищення ліміту: додано можливість перевірки, чи було перевищено ліміт для конкретного пристрою. Це можна зробити за допомогою методу CheckLimitExceeded в контролері, який буде повертати інформацію, чи перевищено ліміт:
        [HttpGet]
        [Route("check-exceeded/{limitId}")]
        public IHttpActionResult CheckLimitExceeded(int limitId)
        {
            try
            {
                var isExceeded = _service.IsLimitExceeded(limitId);
                return Ok(new { LimitExceeded = isExceeded });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        } 
     Прогрес ліміту: для виведення прогресу використаємо метод GetLimitProgress, який обчислює процент виконання ліміту:
        [HttpGet]
        [Route("progress/{limitId}")]
        public IHttpActionResult GetLimitProgress(int limitId)
        {
            try
            {
                var progress = _service.GetLimitProgress(limitId);
                return Ok(new { Progress = progress });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        } 
     Це рішення дозволить зручно моніторити та управляти лімітами споживання води в системі AquaTrack.
     
     Щоб реалізувати додавання нового ліміту для водоспоживання з валідацією введених даних, можна розглянути наступні кроки:
     Валідація введених даних: перед тим, як додавати ліміт до бази даних, потрібно провести перевірку правильності введених даних. Валідація повинна охоплювати:
• Перевірка, що значення ліміту (LimitValue) є додатнім числом.
• Перевірка, що дата початку (StartDate) менша за дату закінчення (EndDate).
• Перевірка на наявність обмежень для користувача чи пристрою на той самий період.
     Реалізація в контролері:
     У контролері LimitsController можна додати метод для створення ліміту, враховуючи валідацію:
        [HttpPost]
        [Route("create")]
        public IHttpActionResult CreateLimit(Limit limit)
        {
            // Валідація
            if (limit.LimitValue <= 0)
            {
                return BadRequest("Значення ліміту повинно бути більшим за 0.");
            }

            if (limit.StartDate >= limit.EndDate)
            {
                return BadRequest("Дата початку повинна бути менша за дату закінчення.");
            }

            var existingLimit = _service.GetAllLimits().FirstOrDefault(l =>
                (l.UserId == limit.UserId || l.DeviceId == limit.DeviceId) &&
                (l.StartDate < limit.EndDate && l.EndDate > limit.StartDate));  // Перевірка на перекриття ліміту
            if (existingLimit != null)
            {
                return BadRequest("Існує ліміт, який перекривається з цим.");
            }

            // Збереження ліміту в базу даних
            _service.CreateLimit(limit);
            return Ok(limit);
        } 
     Валідація та збереження у сервісному класі:
     У класі LimitService для створення ліміту додамо додаткові перевірки:

        public void CreateLimit(Limit limit)
        {
            // Перевірка на наявність періодів, що перекриваються
            var existingLimit = _repository.GetAll().FirstOrDefault(l =>
                (l.UserId == limit.UserId || l.DeviceId == limit.DeviceId) &&
                (l.StartDate < limit.EndDate && l.EndDate > limit.StartDate));

            if (existingLimit != null)
            {
                throw new ArgumentException("Існує ліміт, який перекривається з цим.");
            }

            _repository.Add(limit);
        } 
     Оновлення репозиторію для додавання:
     У класі LimitRepository реалізація методу Add виглядатиме стандартно:
        public void Add(Limit entity)
        {
            _context.Limits.Add(entity);
            _context.SaveChanges();
        } 
     Цей процес гарантує, що дані будуть коректно оброблені перед тим, як зберігатися в базі даних.
     
     Для реалізації функціоналу «Оновлення існуючих лімітів» у системі, вже маємо основні класи та методи, які допоможуть здійснити оновлення ліміту. 
     Отримання ліміту за ідентифікатором:
     Отримання ліміту виконується в методі GetLimitById сервісу LimitService:
        public Limit GetLimitById(int id)
        {
            return _repository.GetById(id);
        } 
     Застосування нових параметрів:
     Прийом оновлених параметрів ліміту, таких як LimitValue, StartDate, EndDate, і застосування їх до поточного запису.
     В контролері (LimitsController) приймаємо об'єкт updatedLimit, який містить нові значення, і оновлюємо ліміт через сервіс:

        [HttpPut]
        [Route("update/{limitId}")]
        public IHttpActionResult UpdateLimit(int limitId, Limit updatedLimit)
        {
            var limit = _service.GetLimitById(limitId);
            if (limit == null) return NotFound();

            // Перевірка на коректність дат
            if (updatedLimit.StartDate > updatedLimit.EndDate)
            {
                return BadRequest("Дата завершення повинна бути після дати початку.");
            }

            updatedLimit.LimitId = limitId; // Встановлюємо ідентифікатор ліміту
            _service.UpdateLimit(updatedLimit); // Оновлення ліміту
            return Ok(updatedLimit); // Повертаємо оновлений ліміт
        } 
     Збереження зміненого запису:
     Збереження оновленого ліміту в базу даних. Це відбувається в методі Update класу LimitRepository, який викликається з сервісу:
        public void Update(Limit entity)
        {
            _context.Entry(entity).State = System.Data.Entity.EntityState.Modified;
            _context.SaveChanges();
        } 
     Пояснення кроків:
• Отримання ліміту за ідентифікатором: знаходимо існуючий ліміт у базі за допомогою ідентифікатора, щоб перевірити його наявність.
• Застосування нових параметрів: після отримання ліміту можемо змінювати будь-які поля (наприклад, нові значення ліміту, дати) перед збереженням у базу.
• Збереження змін: внесені зміни записуються назад у базу даних, використовуючи метод Update.
     Таким чином, маємо повністю функціональну систему для оновлення лімітів, яка забезпечує валідацію та збереження змін.
     Для реалізації функціоналу видалення ліміту з перевіркою на наявність залежностей (історії використання води)  потрібно додати логіку перевірки перед видаленням ліміту. Якщо ліміт має записи в історії використання води, то не можна його видаляти, або, принаймні, потрібно повідомити користувача про це.
     Модифікуємо метод видалення в LimitService.cs та LimitsController.cs.
     Додавання перевірки в LimitService.cs:
     У класі LimitService потрібно перевіряти, чи є історія використання води для певного ліміту перед його видаленням:
        public void DeleteLimit(int id)
        {
            var limit = _repository.GetById(id);
            if (limit == null) throw new ArgumentException("Ліміт не знайдено.");

            // Перевірка на наявність історії використання води
            var usageHistory = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Any();

            if (usageHistory)
            {
                throw new InvalidOperationException("Неможливо видалити ліміт, оскільки з ним пов'язана історія використання води.");
            }

            _repository.Delete(id);  // Видалення ліміту
        } 
     Оновлення контролера LimitsController.cs:
     У контролері потрібно обробити виняток, який може виникнути під час спроби видалення ліміту:
        [HttpDelete]
        [Route("delete/{limitId}")]
        public IHttpActionResult DeleteLimit(int limitId)
        {
            try
            {
                var limit = _service.GetLimitById(limitId);
                if (limit == null) return NotFound();

                _service.DeleteLimit(limitId);  // Викликається метод видалення ліміту
                return Ok();
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);  // Обробка помилки, якщо ліміт не можна видалити
            }
            catch (Exception ex)
            {
                return InternalServerError(ex);  // Інші помилки
            }
        } 
     Пояснення:
1. Перевірка на наявність історії використання: перед видаленням ліміту в методі DeleteLimit перевіряється, чи існує історія використання води, яка відповідає цьому ліміту. Якщо такі записи є, то видалення не проводиться, і викидається виключення InvalidOperationException.
2. Обробка помилки у контролері: Якщо спроба видалення ліміту зазнає помилки, наприклад, через наявність історії використання, контролер повертає клієнту помилку з відповідним повідомленням.
     Таким чином, можемо захистити систему від видалення лімітів, що мають історію використання, і надаємо користувачеві корисне повідомлення про помилку.
     
     Для реалізації функціоналу перегляду історії водоспоживання з можливістю фільтрації за пристроями або періодом, потрібно додати параметри для фільтрації в методи контролера та сервісу.
     Оновлення методу GetUsageHistory в WaterUsageService.cs:
     Додамо можливість фільтрації даних за періодом і пристроєм:
        public IEnumerable<WaterUsage> GetUsageHistory(int? deviceId = null, DateTime? startDate = null, DateTime? endDate = null)
        {
            var query = _repository.GetAll().AsQueryable();

            if (deviceId.HasValue)
            {
                query = query.Where(w => w.DeviceId == deviceId.Value);
            }

            if (startDate.HasValue)
            {
                query = query.Where(w => w.Timestamp >= startDate.Value);
            }

            if (endDate.HasValue)
            {
                query = query.Where(w => w.Timestamp <= endDate.Value);
            }

            return query.OrderByDescending(w => w.Timestamp).ToList();
        } 
     Оновлення методу GetHistory в WaterUsageController.cs:
     Тепер додамо параметри для фільтрації в контролер. Можемо передавати параметри, такі як deviceId, startDate, і endDate у запиті:
        [HttpGet]
        [Route("history")]
        public IHttpActionResult GetHistory(int? deviceId = null, DateTime? startDate = null, DateTime? endDate = null)
        {
            try
            {
                var history = _service.GetUsageHistory(deviceId, startDate, endDate);
                return Ok(history);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        } 
     Оновлення методу GetAverageUsage для обробки періоду:
     Ми вже маємо метод для обчислення середнього використання води за період, але потрібно переконатись, що він працює коректно із зазначенням дат:
        [HttpGet]
        [Route("average-usage")]
        public IHttpActionResult GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            try
            {
                var averageUsage = _service.GetAverageUsage(deviceId, startDate, endDate);
                return Ok(averageUsage);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        } 
     Пояснення:
1. Фільтрація за пристроєм і періодом: метод GetUsageHistory дозволяє фільтрувати записи за пристроєм (deviceId), датою початку (startDate) та датою кінця (endDate). Параметри можуть бути необов'язковими, тому їх можна передавати через URL-запит.
2. Фільтрація в контролері: контролер приймає параметри через запит, що дозволяє фільтрувати дані на сервері перед тим, як повернути їх користувачу.
3. Обчислення середнього використання: в GetAverageUsage можна отримати середнє значення використання води за заданий період для конкретного пристрою.
     Це забезпечить функціональність перегляду історії водоспоживання з фільтрацією за пристроєм і датами, а також можливість обчислення середнього використання води за конкретний період.


4 ВИСНОВКИ
     
     
     У межах цієї лабораторної роботи було виконано повноцінну розробку архітектури серверної частини програмної системи, що включає побудову її основних компонентів та взаємодії між ними. Було визначено та реалізовано ключові елементи: REST API, бізнес-логіку, взаємодію з базою даних через ORM (Entity Framework), а також обробку запитів із різних типів клієнтів (WinForms-додаток, мобільний застосунок на Kotlin, веб-інтерфейс на основі React SPA та IoT-пристрій).
     Побудована діаграма архітектури дозволила чітко структурувати логіку взаємодії між клієнтськими та серверними компонентами, що забезпечує масштабованість і модульність системи. Усі взаємозв’язки між компонентами були проаналізовані та доповнені зазначенням відповідних протоколів (HTTP, SQL, ORM), що сприяє прозорості та зрозумілості реалізованої архітектури.
     Результатом виконання роботи стало створення надійної основи серверної частини програмної системи, яка здатна ефективно обробляти запити, зберігати й обробляти дані, а також забезпечувати взаємодію з різними типами клієнтів. Такий підхід сприяє побудові гнучкого, підтримуваного та масштабованого програмного продукту.









ДОДАТОК А


     Відеозапис презентації результатів лабораторної роботи: https://youtu.be/P1DuRPKaXeI
     Хронологічний опис: 
     00:00 – Вступ. 
     00:14 – База даних для програмної системи. 
     00:57 – Опис використаних технологій. 
     02:10 – Пояснення головних файлів програми(Startup та Program) та Swagger. 
     03:06 – Пояснення файлів Models та підключення до бази даних. 
     03:57 – Пояснення файлів Controllers, які відправляють запити. 
     04:22 – Пояснення файлів Repositories(взаємодія з базою даних). 
     05:01 – Пояснення файлів Services. 
     05:58 – Бізнес логіка та функції адміністрування серверної частини програмної системи. 
     06:04 – Опис доданих функцій для User. 
     09:00 – Опис доданих функцій для IoTDevice. 
     10:05 – Опис доданих функцій для Limit. 
     12:53 – Опис доданих функцій для WaterUsage. 
     14:44 – Висновок.








ДОДАТОК Б
Графічні матеріали


   Рисунок 1 - UML діаграма прецедентів для серверної частини системи.
   

Рисунок 2 – UML діаграма діяльності для серверної частини.

Рисунок 3 – UML діаграма взаємодії для серверної частини.
   

Рисунок 4 – UML діаграму розгортання (Deployment Diagram)
   

Рисунок 5 – ER діаграма даних.

Рисунок 6 – діаграма структури бази даних.

Рисунок 7 – документація для API Swagger.

Рисунок 8 – розгорнута документація для API Swagger.

     Рисунок 9 – користувача успішно зареєстровано.

Рисунок 10 – успішна авторизація.


Рисунок 11 – авторизація з неправильними даними.

Рисунок 12 – Введення некоректної дати.

Рисунок 13 – Введення некоректного зачення.
     
     
     
     
ДОДАТОК В
Код для створення таблиць у базі даних
USE aquatrack;

-- Таблиця користувачів
CREATE TABLE Users (
    user_id INT IDENTITY(1,1) PRIMARY KEY, -- Унікальний ідентифікатор користувача
    username VARCHAR(50) NOT NULL,          -- Ім'я користувача
    email VARCHAR(100) UNIQUE NOT NULL,     -- Електронна пошта
    password_hash VARCHAR(255) NOT NULL,    -- Хеш пароля
    role NVARCHAR(10) CHECK (role IN ('user', 'admin')) NOT NULL -- Роль (користувач/адміністратор)
);

-- Таблиця IoT пристроїв
CREATE TABLE IoT_Device (
    device_id INT IDENTITY(1,1) PRIMARY KEY, -- Унікальний ідентифікатор пристрою
    device_type NVARCHAR(50) NOT NULL,       -- Тип пристрою (водомір, датчик витрати)
    status NVARCHAR(10) CHECK (status IN ('active', 'inactive')) NOT NULL DEFAULT 'active' -- Статус пристрою
);

-- Таблиця лімітів на споживання
CREATE TABLE Limits (
    limit_id INT IDENTITY(1,1) PRIMARY KEY, -- Унікальний ідентифікатор ліміту
    limit_value DECIMAL(10, 2) NOT NULL,     -- Максимальне значення споживання води
    start_date DATE NOT NULL,                -- Дата початку дії ліміту
    end_date DATE NOT NULL,                  -- Дата закінчення дії ліміту
    user_id INT NOT NULL,                    -- Зовнішній ключ до користувача
    device_id INT NOT NULL,                  -- Зовнішній ключ до IoT-пристрою
    FOREIGN KEY (user_id) REFERENCES Users(user_id) ON DELETE CASCADE,
    FOREIGN KEY (device_id) REFERENCES IoT_Device(device_id) ON DELETE CASCADE
);

-- Таблиця споживання води
CREATE TABLE Water_Usage (
    usage_id INT IDENTITY(1,1) PRIMARY KEY, -- Унікальний ідентифікатор запису
    device_id INT NOT NULL,                  -- Зовнішній ключ до IoT-пристрою
    usage_value DECIMAL(10, 2) NOT NULL,     -- Кількість спожитої води
    timestamp DATETIME NOT NULL,             -- Дата та час вимірювання
    FOREIGN KEY (device_id) REFERENCES IoT_Device(device_id) ON DELETE CASCADE
);


Репозиторії(Repositories)
      IRepository.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AquaTrack.Repositories
{
    public interface IRepository<T> where T : class
    {
        IEnumerable<T> GetAll();
        T GetById(int id);
        void Add(T entity);
        void Update(T entity);
        void Delete(int id);
    }
}
     
     UserRepository.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AquaTrack.Data;
using AquaTrack.Data.Models;

namespace AquaTrack.Repositories
{
    public class UserRepository : IRepository<User>
    {
        private readonly AppDbContext _context;

        public UserRepository(AppDbContext context)
        {
            _context = context;
        }

        public IEnumerable<User> GetAll()
        {
            return _context.Users.ToList();
        }

        public User GetById(int id)
        {
            return _context.Users.Find(id);
        }

        public void Add(User entity)
        {
            _context.Users.Add(entity);
            _context.SaveChanges();
        }

        public void Update(User entity)
        {
            _context.Entry(entity).State = System.Data.Entity.EntityState.Modified;
            _context.SaveChanges();
        }

        public void Delete(int id)
        {
            var user = _context.Users.Find(id);
            if (user != null)
            {
                _context.Users.Remove(user);
                _context.SaveChanges();
            }
        }
    }
}

     IoTDeviceRepository.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AquaTrack.Data;
using AquaTrack.Data.Models;

namespace AquaTrack.Repositories
{
    public class IoTDeviceRepository : IRepository<IoTDevice>
    {
        private readonly AppDbContext _context;

        public IoTDeviceRepository(AppDbContext context)
        {
            _context = context;
        }

        public IEnumerable<IoTDevice> GetAll()
        {
            return _context.IoTDevices.ToList();
        }

        public IoTDevice GetById(int id)
        {
            return _context.IoTDevices.Find(id);
        }

        public void Add(IoTDevice entity)
        {
            _context.IoTDevices.Add(entity);
            _context.SaveChanges();
        }

        public void Update(IoTDevice entity)
        {
            _context.Entry(entity).State = System.Data.Entity.EntityState.Modified;
            _context.SaveChanges();
        }

        public void Delete(int id)
        {
            var device = _context.IoTDevices.Find(id);
            if (device != null)
            {
                _context.IoTDevices.Remove(device);
                _context.SaveChanges();
            }
        }
    }
}

     WaterUsageRepository.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AquaTrack.Data;
using AquaTrack.Data.Models;

namespace AquaTrack.Repositories
{
    public class WaterUsageRepository : IRepository<WaterUsage>
    {
        private readonly AppDbContext _context;

        public WaterUsageRepository(AppDbContext context)
        {
            _context = context;
        }

        public IEnumerable<WaterUsage> GetAll()
        {
            return _context.WaterUsages.ToList();
        }

        public WaterUsage GetById(int id)
        {
            return _context.WaterUsages.Find(id);
        }

        public void Add(WaterUsage entity)
        {
            _context.WaterUsages.Add(entity);
            _context.SaveChanges();
        }

        public void Update(WaterUsage entity)
        {
            _context.Entry(entity).State = System.Data.Entity.EntityState.Modified;
            _context.SaveChanges();
        }

        public void Delete(int id)
        {
            var usage = _context.WaterUsages.Find(id);
            if (usage != null)
            {
                _context.WaterUsages.Remove(usage);
                _context.SaveChanges();
            }
        }
    }
}

     LimitRepository.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AquaTrack.Data;
using AquaTrack.Data.Models;

namespace AquaTrack.Repositories
{
    public class LimitRepository : IRepository<Limit>
    {
        private readonly AppDbContext _context;

        public LimitRepository(AppDbContext context)
        {
            _context = context;
        }

        public IEnumerable<Limit> GetAll()
        {
            return _context.Limits.ToList();
        }

        public Limit GetById(int id)
        {
            return _context.Limits.Find(id);
        }

        public void Add(Limit entity)
        {
            _context.Limits.Add(entity);
            _context.SaveChanges();
        }

        public void Update(Limit entity)
        {
            _context.Entry(entity).State = System.Data.Entity.EntityState.Modified;
            _context.SaveChanges();
        }

        public void Delete(int id)
        {
            var limit = _context.Limits.Find(id);
            if (limit != null)
            {
                _context.Limits.Remove(limit);
                _context.SaveChanges();
            }
        }
    }
}

Контролери(Controllers)
     UsersController.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Web.Http;
using AquaTrack.Data.Models;
using AquaTrack.Services;

namespace AquaTrack.Controllers
{
    [RoutePrefix("api/users")]
    public class UsersController : ApiController
    {
        private readonly UserService _service;

        public UsersController(UserService service)
        {
            _service = service;
        }

        [HttpPost]
        [Route("register")]
        public IHttpActionResult Register(User user)
        {
            try
            {
                _service.RegisterUser(user);
                return Ok("Користувач успішно зареєстрований.");
            }
            catch (Exception ex)
            {
                return BadRequest(ex.Message);
            }
        }

        [HttpPost]
        [Route("login")]
        public IHttpActionResult Login(string email, string password)
        {
            //var user = _service.Authenticate(email, passwordHash);
            //if (user == null) return Unauthorized();

            //return Ok(user);

            try
            {
                var user = _service.Authenticate(email, password);
                return Ok(new
                {
                    Message = "Успішна авторизація",
                    UserId = user.UserId,
                    Username = user.Username,
                    Role = user.Role
                });
            }
            catch (Exception ex)
            {
                return Unauthorized(); // Неправильний логін або пароль
            }
        }

        [HttpPut]
        [Route("update-profile")]
        public IHttpActionResult UpdateProfile(User updatedUser)
        {
            var user = _service.GetUserById(updatedUser.UserId);
            if (user == null) return NotFound();

            updatedUser.UserId = user.UserId;
            _service.UpdateUser(updatedUser);
            return Ok(updatedUser);
        }

        [HttpGet]
        [Route("list")]
        public IHttpActionResult GetUsers(string role = null)
        {
            var currentUserRole = "Admin"; // Перевірка ролі
            if (currentUserRole != "Admin")
            {
                return Content(HttpStatusCode.Forbidden, "Доступ дозволений тільки адміністраторам.");
            }

            var users = _service.GetAllUsers();
            if (!string.IsNullOrEmpty(role))
            {
                users = users.Where(u => u.Role.Equals(role, StringComparison.OrdinalIgnoreCase));
            }

            return Ok(users);
        }

        [HttpPut]
        [Route("update-role")]
        public IHttpActionResult UpdateRole(int userId, string newRole)
        {
            try
            {
                var user = _service.GetUserById(userId);
                if (user == null)
                {
                    return NotFound(); // Користувача не знайдено
                }

                // Перевірка нової ролі
                var validRoles = new List<string> { "User", "Admin", "Moderator" }; // Додайте ваші ролі
                if (!validRoles.Contains(newRole))
                {
                    return BadRequest("Невірна роль.");
                }

                // Оновлення ролі
                user.Role = newRole;
                _service.UpdateUser(user);

                return Ok($"Роль користувача з ID {userId} успішно змінено на {newRole}.");
            }
            catch (Exception ex)
            {
                return BadRequest($"Помилка при оновленні ролі: {ex.Message}");
            }
        }

        [HttpDelete]
        [Route("delete/{id}")]
        public IHttpActionResult DeleteUser(int id)
        {
            var currentUserRole = "Admin"; // Замінити на реальну перевірку ролі

            if (currentUserRole != "Admin")
            {
                return Content(HttpStatusCode.Forbidden, "Доступ дозволений тільки адміністраторам.");
            }

            try
            {
                var user = _service.GetUserById(id);
                if (user == null)
                {
                    return NotFound();
                }

                _service.DeleteUser(id);
                return Ok($"Користувача з ID {id} успішно видалено.");
            }
            catch (Exception ex)
            {
                return BadRequest($"Помилка видалення: {ex.Message}");
            }
        }

    }
}

     
     IoTDevicesController.cs:
using System;
using System.Linq;
using System.Web.Http;
using AquaTrack.Data.Models;
using AquaTrack.Services;

namespace AquaTrack.Controllers
{
    [RoutePrefix("api/iot-devices")]
    public class IoTDevicesController : ApiController
    {
        private readonly IoTDeviceService _service;
        private readonly WaterUsageService _waterUsageService;

        public IoTDevicesController(IoTDeviceService service)
        {
            _service = service;
        }

        [HttpGet]
        [Route("list")]
        public IHttpActionResult GetDevices()
        {
            var devices = _service.GetAllDevices();
            return Ok(devices);
        }

        [HttpPost]
        [Route("register")]
        public IHttpActionResult RegisterDevice(IoTDevice device)
        {
            if (_service.GetAllDevices().Any(d => d.DeviceType == device.DeviceType))
                return BadRequest("Device type already exists.");

            _service.AddDevice(device);
            return Ok(device);
        }

        [HttpDelete]
        [Route("delete/{deviceId}")]
        public IHttpActionResult DeleteDevice(int deviceId)
        {
            var device = _service.GetDeviceById(deviceId);
            if (device == null) return NotFound();

            _service.DeleteDevice(deviceId);
            return Ok();
        }

        [HttpPost]
        [Route("collect-data")]
        public IHttpActionResult CollectData(WaterUsage data)
        {
            try
            {
                _waterUsageService.AddUsageRecord(data, _service);
                return Ok("Data collected successfully.");
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        }

        [HttpGet]
        [Route("list-by-status")]
        public IHttpActionResult GetDevicesByStatus(string status)
        {
            var devices = _service.GetAllDevices()
                                  .Where(d => d.Status.Equals(status, StringComparison.OrdinalIgnoreCase))
                                  .ToList();

            if (!devices.Any())
                return NotFound();

            return Ok(devices);
        }

    }
}

     
     WaterUsageController.cs:
using System;
using System.Web.Http;
using AquaTrack.Services;

namespace AquaTrack.Controllers
{
    [RoutePrefix("api/water-usage")]
    public class WaterUsageController : ApiController
    {
        private readonly WaterUsageService _service;

        public WaterUsageController(WaterUsageService service)
        {
            _service = service;
        }

        [HttpGet]
        [Route("current/{deviceId}")]
        public IHttpActionResult GetCurrentUsage(int deviceId)
        {
            var currentUsage = _service.GetCurrentUsage(deviceId);
            if (currentUsage == null)
                return NotFound();

            return Ok(currentUsage);
        }

        [HttpGet]
        [Route("history")]
        public IHttpActionResult GetHistory(int? deviceId = null, DateTime? startDate = null, DateTime? endDate = null)
        {
            try
            {
                var history = _service.GetUsageHistory(deviceId, startDate, endDate);
                return Ok(history);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        }

        [HttpGet]
        [Route("average-usage")]
        public IHttpActionResult GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            try
            {
                var averageUsage = _service.GetAverageUsage(deviceId, startDate, endDate);
                return Ok(averageUsage);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        }

    }
}

     
     LimitsController.cs:
using System;
using System.Linq;
using System.Web.Http;
using AquaTrack.Data.Models;
using AquaTrack.Services;

namespace AquaTrack.Controllers
{
    [RoutePrefix("api/limits")]
    public class LimitsController : ApiController
    {
        private readonly LimitService _service;

        public LimitsController(LimitService service)
        {
            _service = service;
        }

        [HttpPost]
        [Route("create")]
        public IHttpActionResult CreateLimit(Limit limit)
        {
            // Валідація
            if (limit.LimitValue <= 0)
            {
                return BadRequest("Значення ліміту повинно бути більшим за 0.");
            }

            if (limit.StartDate >= limit.EndDate)
            {
                return BadRequest("Дата початку повинна бути менша за дату закінчення.");
            }

            var existingLimit = _service.GetAllLimits().FirstOrDefault(l =>
                (l.UserId == limit.UserId || l.DeviceId == limit.DeviceId) &&
                (l.StartDate < limit.EndDate && l.EndDate > limit.StartDate));  // Перевірка на перекриття ліміту
            if (existingLimit != null)
            {
                return BadRequest("Існує ліміт, який перекривається з цим.");
            }

            // Збереження ліміту в базу даних
            _service.CreateLimit(limit);
            return Ok(limit);
        }

        [HttpPut]
        [Route("update/{limitId}")]
        public IHttpActionResult UpdateLimit(int limitId, Limit updatedLimit)
        {
            var limit = _service.GetLimitById(limitId);
            if (limit == null) return NotFound();

            // Перевірка на коректність дат
            if (updatedLimit.StartDate > updatedLimit.EndDate)
            {
                return BadRequest("Дата завершення повинна бути після дати початку.");
            }

            updatedLimit.LimitId = limitId; // Встановлюємо ідентифікатор ліміту
            _service.UpdateLimit(updatedLimit); // Оновлення ліміту
            return Ok(updatedLimit); // Повертаємо оновлений ліміт
        }

        [HttpDelete]
        [Route("delete/{limitId}")]
        public IHttpActionResult DeleteLimit(int limitId)
        {
            try
            {
                var limit = _service.GetLimitById(limitId);
                if (limit == null) return NotFound();

                _service.DeleteLimit(limitId);  // Викликається метод видалення ліміту
                return Ok();
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);  // Обробка помилки, якщо ліміт не можна видалити
            }
            catch (Exception ex)
            {
                return InternalServerError(ex);  // Інші помилки
            }
        }

        [HttpGet]
        [Route("check-exceeded/{limitId}")]
        public IHttpActionResult CheckLimitExceeded(int limitId)
        {
            try
            {
                var isExceeded = _service.IsLimitExceeded(limitId);
                return Ok(new { LimitExceeded = isExceeded });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        }

        [HttpGet]
        [Route("progress/{limitId}")]
        public IHttpActionResult GetLimitProgress(int limitId)
        {
            try
            {
                var progress = _service.GetLimitProgress(limitId);
                return Ok(new { Progress = progress });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        }

        [HttpGet]
        [Route("list")]
        public IHttpActionResult GetLimits()
        {
            var limits = _service.GetAllLimits();
            return Ok(limits);
        }

    }
}

Моделі(Models)
     IoTDevice.cs:
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AquaTrack.Data.Models
{
    public class IoTDevice
    {
        [Key]
        [Column("device_id")]
        public int DeviceId { get; set; }
        [Column("device_type")]
        public string DeviceType { get; set; }
        [Column("status")]
        public string Status { get; set; }

        // Зв’язок із таблицею Limits
        public ICollection<Limit> Limits { get; set; }
    }
}
     
     Limit.cs:
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AquaTrack.Data.Models
{
    public class Limit
    {
        [Key]
        [Column("limit_id")]
        public int LimitId { get; set; }           // Унікальний ідентифікатор ліміту
        [Range(0.01, double.MaxValue, ErrorMessage = "Ліміт повинен бути більшим за 0.")]
        [Column("limit_value")]
        public decimal LimitValue { get; set; }   // Максимальне значення споживання води
        [Column("start_date")]
        public DateTime StartDate { get; set; }   // Дата початку дії ліміту
        [Column("end_date")]
        public DateTime EndDate { get; set; }     // Дата закінчення дії ліміту

        // Зовнішні ключі
        [Column("user_id")]
        public int UserId { get; set; }           // Зв'язок із користувачами
        public User User { get; set; }            // Навігаційна властивість
        
        [Column("device_id")]
        public int DeviceId { get; set; }         // Зв'язок із IoT-пристроями
        public IoTDevice IoTDevice { get; set; }  // Навігаційна властивість
    }
}
     
     Users.cs:
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AquaTrack.Data.Models
{
    public class User
    {
        [Key]
        [Column("user_id")]
        public int UserId { get; set; }
        [Column("username")]
        public string Username { get; set; }
        [Column("email")]
        public string Email { get; set; }
        [Column("password_hash")]
        public string PasswordHash { get; set; }
        [Column("role")]
        public string Role { get; set; }
    }
}
     
     WaterUsage.cs:
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AquaTrack.Data.Models
{
    public class WaterUsage
    {
        [Key]
        [Column("usage_id")]
        public int UsageId { get; set; }         // Унікальний ідентифікатор запису
        [Column("usage_value")]
        public decimal UsageValue { get; set; } // Кількість спожитої води
        [Column("timestamp")]
        public DateTime Timestamp { get; set; } // Дата та час вимірювання

        // Зовнішній ключ
        [Column("device_id")]
        public int DeviceId { get; set; }       // Зв'язок із IoT-пристроями
        public IoTDevice IoTDevice { get; set; } // Навігаційна властивість
    }
}
     
Сервіси(Services)
     IoTDeviceService.cs:
using System;
using System.Collections.Generic;
using AquaTrack.Data.Models;
using AquaTrack.Repositories;

namespace AquaTrack.Services
{
    public class IoTDeviceService
    {
        private readonly IRepository<IoTDevice> _repository;

        public IoTDeviceService(IRepository<IoTDevice> repository)
        {
            _repository = repository;
        }

        public IEnumerable<IoTDevice> GetAllDevices()
        {
            return _repository.GetAll();
        }

        public IoTDevice GetDeviceById(int id)
        {
            return _repository.GetById(id);
        }

        public void AddDevice(IoTDevice device)
        {
            _repository.Add(device);
        }

        public void UpdateDevice(IoTDevice device)
        {
            _repository.Update(device);
        }

        public void DeleteDevice(int id)
        {
            _repository.Delete(id);
        }
    }
}
     
     LimitService.cs:
using System.Collections.Generic;
using AquaTrack.Data.Models;
using AquaTrack.Repositories;
using System.Linq;
using AquaTrack.Data;
using System;

namespace AquaTrack.Services
{
    public class LimitService
    {
        private readonly IRepository<Limit> _repository;
        private readonly IRepository<WaterUsage> _waterUsageRepository;

        public LimitService(IRepository<Limit> repository, IRepository<WaterUsage> waterUsageRepository)
        {
            _repository = repository;
            _waterUsageRepository = waterUsageRepository;
        }

        public IEnumerable<Limit> GetAllLimits()
        {
            return _repository.GetAll();
        }

        public Limit GetLimitById(int id)
        {
            return _repository.GetById(id);
        }

        public void CreateLimit(Limit limit)
        {
            // Перевірка на наявність періодів, що перекриваються
            var existingLimit = _repository.GetAll().FirstOrDefault(l =>
                (l.UserId == limit.UserId || l.DeviceId == limit.DeviceId) &&
                (l.StartDate < limit.EndDate && l.EndDate > limit.StartDate));

            if (existingLimit != null)
            {
                throw new ArgumentException("Існує ліміт, який перекривається з цим.");
            }

            _repository.Add(limit);
        }

        public void UpdateLimit(Limit limit)
        {
            _repository.Update(limit);
        }

        public void DeleteLimit(int id)
        {
            var limit = _repository.GetById(id);
            if (limit == null) throw new ArgumentException("Ліміт не знайдено.");

            // Перевірка на наявність історії використання води
            var usageHistory = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Any();

            if (usageHistory)
            {
                throw new InvalidOperationException("Неможливо видалити ліміт, оскільки з ним пов'язана історія використання води.");
            }

            _repository.Delete(id);  // Видалення ліміту
        }

        public bool IsLimitExceeded(int limitId)
        {
            var limit = _repository.GetById(limitId);
            if (limit == null) throw new ArgumentException("Limit not found.");

            var totalUsage = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Sum(w => w.UsageValue);

            return totalUsage > limit.LimitValue;
        }

        public decimal GetLimitProgress(int limitId)
        {
            var limit = _repository.GetById(limitId);
            if (limit == null) throw new ArgumentException("Limit not found.");

            var totalUsage = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Sum(w => w.UsageValue);

            return (totalUsage / limit.LimitValue) * 100;
        }

    }
}

     UserService.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using AquaTrack.Data.Models;
using AquaTrack.Repositories;
using BCrypt.Net;

namespace AquaTrack.Services
{
    public class UserService
    {
        private readonly IRepository<User> _repository;

        public UserService(IRepository<User> repository)
        {
            _repository = repository;
        }

        public IEnumerable<User> GetAllUsers(string role = null)
        {
            var users = _repository.GetAll();
            if (!string.IsNullOrEmpty(role))
            {
                users = users.Where(u => u.Role.Equals(role, StringComparison.OrdinalIgnoreCase));
            }
            return users;
        }

        public User GetUserById(int id)
        {
            return _repository.GetById(id);
        }

        public void RegisterUser(User user)
        {
            // Перевірка, чи існує користувач із таким email
            if (_repository.GetAll().Any(u => u.Email == user.Email))
            {
                throw new Exception("Користувач із таким email вже існує.");
            }

            // Хешування пароля
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(user.PasswordHash);

            // Призначення ролі за замовчуванням
            user.Role = "User";

            // Додавання користувача до бази
            _repository.Add(user);
        }

        public void UpdateUser(User user)
        {
            _repository.Update(user);
        }

        public void UpdateUserRole(int userId, string newRole)
        {
            var user = GetUserById(userId);
            if (user == null)
            {
                throw new Exception("Користувача не знайдено.");
            }

            user.Role = newRole;
            UpdateUser(user);
        }

        public void DeleteUser(int id)
        {
            var user = _repository.GetById(id);
            if (user == null)
            {
                throw new Exception("Користувача з таким ID не знайдено.");
            }

            _repository.Delete(id);
        }

        public User Authenticate(string email, string password)
        {
            //return _repository
            //    .GetAll()
            //    .FirstOrDefault(u => u.Email == email && u.PasswordHash == passwordHash);

            // Пошук користувача за email
            var user = _repository.GetAll().FirstOrDefault(u => u.Email == email);

            if (user == null)
            {
                throw new Exception("Користувача з таким email не знайдено.");
            }

            // Перевірка хешованого пароля
            if (!BCrypt.Net.BCrypt.Verify(password, user.PasswordHash))
            {
                throw new Exception("Невірний пароль.");
            }

            return user;
        }
    }
}
     
     WaterUsageService.cs:
using System;
using System.Collections.Generic;
using System.Linq;
using AquaTrack.Data.Models;
using AquaTrack.Repositories;

namespace AquaTrack.Services
{
    public class WaterUsageService
    {
        private readonly IRepository<WaterUsage> _repository;

        public WaterUsageService(IRepository<WaterUsage> repository)
        {
            _repository = repository;
        }

        public WaterUsage GetCurrentUsage(int deviceId)
        {
            return _repository
                .GetAll()
                .Where(w => w.DeviceId == deviceId)
                .OrderByDescending(w => w.Timestamp)
                .FirstOrDefault();
        }

        public IEnumerable<WaterUsage> GetUsageHistory(int? deviceId = null, DateTime? startDate = null, DateTime? endDate = null)
        {
            var query = _repository.GetAll().AsQueryable();

            if (deviceId.HasValue)
            {
                query = query.Where(w => w.DeviceId == deviceId.Value);
            }

            if (startDate.HasValue)
            {
                query = query.Where(w => w.Timestamp >= startDate.Value);
            }

            if (endDate.HasValue)
            {
                query = query.Where(w => w.Timestamp <= endDate.Value);
            }

            return query.OrderByDescending(w => w.Timestamp).ToList();
        }

        public void AddUsageRecord(WaterUsage usage, IoTDeviceService deviceService)
        {
            // Перевірка пристрою
            var device = deviceService.GetDeviceById(usage.DeviceId);
            if (device == null)
                throw new ArgumentException($"Device with ID {usage.DeviceId} not found.");

            // Перевірка дублювання запису
            var existingRecord = _repository.GetAll()
                .FirstOrDefault(w => w.DeviceId == usage.DeviceId && w.Timestamp == usage.Timestamp);

            if (existingRecord != null)
                throw new ArgumentException("Duplicate record for the same device and timestamp.");

            // Валідація обсягу
            if (usage.UsageValue < 0)
                throw new ArgumentException("Usage value cannot be negative.");

            // Додавання запису
            _repository.Add(usage);
        }

        public void DeleteUsageRecord(int id)
        {
            _repository.Delete(id);
        }

        public decimal GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            var usageRecords = _repository
                .GetAll()
                .Where(w => w.DeviceId == deviceId && w.Timestamp >= startDate && w.Timestamp <= endDate)
                .ToList();

            if (!usageRecords.Any())
                throw new ArgumentException("No usage records found for the specified period.");

            // Підрахунок загального використання і середнього
            var totalUsage = usageRecords.Sum(w => w.UsageValue);
            var daysCount = (endDate - startDate).Days;

            return totalUsage / daysCount;
        }

    }
}
     
     
